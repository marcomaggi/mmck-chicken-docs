\input texinfo.tex
@c %**start of header
@setfilename chicken-internals.info
@settitle @sc{mmck} @sc{chicken} Internals
@c %**end of header

@include vers-chicken-internals.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @sc{mmck} @sc{chicken} Internals

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @sc{mmck} @sc{chicken} Docs

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           chicken-internals

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2019

@set CHICKEN_VERSION            5.0.0

@c ------------------------------------------------------------

@set GithubUrl                  @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl                @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl           @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro mmck{}
@sc{mmck}
@end macro

@macro chicken{}
@sc{chicken}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes the internals of @chicken{} version @value{CHICKEN_VERSION}, it was last
updated @value{UPDATED}; this document is part of @value{PACKAGE}, a collection of unofficial
documentation about the @chicken{} compiler and its development ecosystem.  @chicken{} is a
Scheme--to--C compiler supporting the language features as defined in the ``Revised^5 Report on
Scheme''.

This package is distributed under the terms of the @url{http://creativecommons.org/licenses/by/3.0/,
Creative Commons Attribution 3.0 License}.  All code fragments in this document are hereby put in
the public domain.

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{UPDATED}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* chicken-internals: (chicken-internals).  Unofficial documentation for
                                           @chicken{} internals.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the document.
* layout::                      Representation of Scheme values.
* checks::                      Checking the result of expressions.
* slots::                       Slots operations.
* structs::                     Low-level structures.
* procs::                       Handling procedure objects.

Appendices

* credits::                     Document authors and source material.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes the internals of @chicken{} version @value{CHICKEN_VERSION}, it was last
updated @value{UPDATED}; this document is part of @value{PACKAGE}, a collection of unofficial
documentation about the @chicken{} compiler and its development environment.  @chicken{} is a
Scheme--to--C compiler supporting the language features as defined in the ``Revised^5 Report on
Scheme''.

@menu
* overview jargon::             Jargon used in this document.
@end menu

@c page
@node overview jargon
@section Jargon used in this document


@cindex System operations
Throughout this document some syntactic bindings are described as @dfn{System Operations}; to be
safe, no matter the actual implementation, we can should of a system operation as a Scheme macro
that, in the end, directly expands into C language code integrated at the macro--use site.  As usual
with macros: we must take care of not causing multiple evaluation of expressions used as arguments
to such operations.

@c page
@node layout
@chapter Representation of Scheme values


@menu
* layout intro::                Immediate and block values.
* layout bitfid::               Bit fiddling.
* layout blocks::               Block objects.
@end menu

@c page
@node layout intro
@section Immediate and block values


@chicken{} attempts to store data in the most ``native'' way it can.  Even though it's written in C,
it tries hard to use machine words everywhere.  So on a 32-bit machine, the native code that's
eventually generated will use 32-bit wide integers and pointers.  On a 64-bit machine it will use
64-bit wide integers and pointers.

This is known as a @samp{C_word}, which is usually defined as an @samp{int} or a @samp{long},
depending on the platform.  By the way, the @samp{C_} prefix stands for @chicken{}, not the C
language.  Every Scheme value is represented as a @samp{C_word} internally.  To understand how this
can work, we need to know that there are roughly two kinds of objects.

@menu
* layout intro immediate::      Immediate values.
* layout intro block::          Block values.
@end menu

@c page
@node layout intro immediate
@subsection Immediate values


These are the typical ``atomic'' values that come up a lot in computations.  It is important to
represent these as efficiently as possible, so they are packed directly in a @samp{C_word}.  This
includes booleans, the empty list, small integers (these are called fixnums), characters and a few
other special values.

Because these values are represented directly by a @samp{C_word}, they can be compared in one
instruction: @func{eq?} in Scheme.  These values do not need to be heap--allocated: they fit
directly in a register, and can be passed around ``by value'' in C.  This also means they don't need
to be tracked by the garbage collector!

At a high enough level, these values simply look like this:

@example
#t #f () 42 #\x
@end example

@c page
@node layout intro block
@subsection Block values


They are values represented pointers to a structure that contains a header and a variable--length
data block.

The data block is a pointer which can conceptually be one of two types.  In case of a string or
@ansrfi{4} object, the data block is simply an opaque ``blob'' or bytevector.  In most other cases,
the block is a compound value consisting of other Scheme objects.  Typical examples are pairs,
vectors and records.

Because these values are heap--allocated, two distinct objects are not stored at the same memory
address, even if they store the same value.  That's why comparing their values is a complex
operation.  This operation is either @func{equal?} for deep structural comparison, or @func{eqv?}
for value comparisons of numbers and symbols.

The @rnrs{5} specification explains that the difference between @func{eq?} and @func{eqv?} is not
necessarily the same across Scheme implementations.  For example, in @chicken{}, @func{eq?} can be
used to compare characters and fixnums, because they are stored as immediate values.  Portable
programs should not rely on that.  If we use @func{eq?} on block objects, their pointers will be
compared: @func{eq?} checks whether they are one and the same object.  This can be a useful
operation in its own right.

Objects represented by data blocks also have to be tracked by the garbage collector: if there are
still references to the block, its data must be copied (recursively) to keep it alive across garbage
collection events.

Here are some ``high level'' examples of block objects:

@smallexample
 --------------------------
| pair 2 slots | #\a | #\b |
 --------------------------

 -------------------------------------------
| vector 5 slots | #f | 123 | 456 | #f | 42 |
 -------------------------------------------

 --------------------------    -----------------------
| string 5 bytes | "hello" |  | flonum 8 bytes | 12.5 |
 --------------------------    -----------------------
        ^                           ^
        |                           |
         ---------                   ---------
                  |                           |
 -----------------+-----     -----------------+------
| pair 2 slots |  O | O-|-->| pair 2 slots |  O | () |
 -----------------------     ------------------------
@end smallexample

@noindent
every block object starts with a header which indicates the type of object and the object's size.
It also determines whether the object's data block is a byte block or a block containing Scheme
objects: if it contains Scheme objects, the header tells us how many slots (locations for storing
Scheme objects) the object has.  Byte blocks, on the other hand, are opaque and can contain any
data.  Their size is stored as a byte count.

From top to bottom, left to right, these represent the following values:

@itemize
@item
@code{(#\a . #\b)} is a pair containing the character @code{a} in its car and @code{b} in its cdr.

@item
@code{#(#f 123 456 #f 42)} is a regular Scheme vector containing fixnums and false values.

@item
@code{"hello"} is a string consisting of 5 characters (strings are treated as byte vectors in
@chicken{}).

@item
@code{12.5} is an inexact representation of the number twelve and a half (a ``flonum'').  This is a
byte block storing the raw byte value of a C @code{double}.

@item
@code{("hello" . (12.5 . ()))} is the first pair of a proper list which contains a string and a
flonum.

@item
@code{(12.5 . ())} is the cdr of that list; a pair containing a number and the end--of--list marker.
@end itemize

The final two pair objects show that slots (like any @code{C_word}) can hold not only immediate
values, but also pointers to block objects.  This leads us to the question: how to differentiate
between a pointer to an object and an immediate object?

@c page
@node layout bitfid
@section Bit fiddling


Most platforms require pointers to words to be aligned on a word boundary.  Thus, on a 32-bit
machine, memory addresses will always have zero in the lower 2 bits, because we can only point to
multiples of 4 bytes.  On a 64-bit machine, word addresses will have zero in the lower 4 bits.

Because the lower two bits are never used, we can perform a simple trick: any value that has either
of the lower two bits set cannot be a word pointer, so we enforce immediate objects to have either
bit set.

@menu
* layout bitfid objrep::        Representation of objects.
* layout bitfid immediate::     Bit patterns of immediate values.
@end menu

@c page
@node layout bitfid objrep
@subsection Representation of objects


We've learned how @chicken{} distinguishes between pointers to (block) objects and immediate values.
Now we will look into the nitty--gritty details of the object representation.

We can make the following breakdown of bit patterns (assuming a 32-bit platform):

@example
XXXXXXXX XXXXXXXX XXXXXXXX XXXXXX00 Pointer to block object
XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXX1 Fixnum (small integer)
XXXXXXXX XXXXXXXX XXXXXXXX XXXXYY10 Other immediate object
@end example

This shows that the lower two bits can be used to distinguish between block objects (zero) and
immediate objects (nonzero).  For immediate objects, the low bit can be used to distinguish between
fixnum objects and other kinds of immediate objects.  Notice that for non--fixnum immediate objects:
the 4 least significant bits @samp{YY10} are used for tagging the value as object of a specific
kind.

Fixnums are distinguished from ``other immediate'' values because fixnums are so incredibly common:
they are used for indexing into strings, loop counters and many calculations.  These have to be
represented as efficiently as possible while storing the widest possible range of values.  Run time
type checking for fixnums should use as few CPU instructions as possible.

The ``other immediate'' types are further differentiated through the top two bits of the lower
nibble:

@example
XXXXXXXX XXXXXXXX XXXXXXXX XXXX0110 Boolean
XXXXXXXX XXXXXXXX XXXXXXXX XXXX1010 Character
XXXXXXXX XXXXXXXX XXXXXXXX XXXX1110 Special object
@end example

The unused ``other immediate'' type of @code{0010} is reserved for future use.  To get a good feel
for the representation of immediates, let us look at a few example bit patterns.  We'll also see how
to construct them in C.

@c page
@node layout bitfid immediate
@subsection Bit patterns of immediate values


@menu
* layout bitfid immediate fixnums::     Bit patterns of fixnums.
* layout bitfid immediate booleans::    Bit patterns of booleans.
* layout bitfid immediate chars::       Bit patterns of characters.
* layout bitfid immediate specials::    Bit patterns of special objects.
@end menu

@c page
@node layout bitfid immediate fixnums
@subsubsection Bit patterns of fixnums


@cindex Fixnums, internal representation
@cindex Internal representation, fixnums


These small integer values are stored in the @strong{two's complement} representation, like the
@cpu{} uses.  The lowest bit is always @samp{1}, due to the fixnum tag bit.  The highest bit is used
to determine the sign of the number.

@example
00000000 00000000 00000000 00000001 value= 0 C_fix(0)
00000000 00000000 00000000 00000011 value= 1 C_fix(+1)
00000000 00000000 00000000 00000101 value= 2 C_fix(+2)
11111111 11111111 11111111 11111111 value=-1 C_fix(-1)
11111111 11111111 11111111 11111101 value=-2 C_fix(-2)
@end example

The @cfunc{C_fix} preprocessor macro shifts its argument one bit to the left, and sets the lower bit
through a bitwise OR with 1.  To convert a Scheme fixnum back to a C integer: we can use the
@cfunc{C_unfix} preprocessor macro, it shifts its argument one bit to the right.  @cfunc{C_fix} and
@cfunc{C_unfix} are defined in the header file @file{chicken.h}.

We might wonder what happens when we calculate or enter a very large integer: in @chicken{} 4, it
will be coerced to a flonum; in @chicken{} 5, it will be stored as a bignum.  Bignums are block
objects, not immediates, because they may be arbitrarily large.

@c page
@node layout bitfid immediate booleans
@subsubsection Bit patterns of booleans


@cindex Booleans, internal representation
@cindex Internal representation, booleans


The representation in machine words uses the 4 least significant bits as tag:

@example
00000000 00000000 00000000 00000110 value=#f C_SCHEME_FALSE
00000000 00000000 00000000 00010110 value=#t C_SCHEME_TRUE
@end example

That's a very large bit space for only two values.  However, reserving a special type tag just for
booleans simplifies type detection code: we only have to compare the lower four bits with
@code{0110} to check whether an object is a boolean.

The constants @code{C_SCHEME_FALSE} and @code{C_SCHEME_TRUE} are preprocessor symbols defined at the
C language level, in the header file @file{chicken.h}.

@c page
@node layout bitfid immediate chars
@subsubsection Bit patterns of characters


@cindex Characters, internal representation
@cindex Internal representation, characters


The representation in machine words uses the least significant byte as tag:

@example
00000000 00000000 00000000 00001010 value=#\nul C_make_character('\0')
00000000 00000000 01000001 00001010 value=#\A   C_make_character('A')
@end example

Characters do not make full use of the available bits, because the lower byte's high nibble is
always @code{0000}.  This means that only 24 bits are available for representing the character on
32-bit platforms; luckily, this is enough for representing the full Unicode range.  If Unicode ever
starts using up a bigger code space, we can always sneak in 4 more bits.

The preprocessor macro @cfunc{C_make_character} is defined in the header file @file{chicken.h}.

@c page
@node layout bitfid immediate specials
@subsubsection Bit patterns of special objects


@cindex Special objects, internal representation
@cindex Internal representation, special objects


The representation in machine words uses the least significant byte:

@example
00000000 00000000 00000000 00001110 value=()      C_SCHEME_END_OF_LIST
00000000 00000000 00000000 00011110 value=(void)  C_SCHEME_UNDEFINED
00000000 00000000 00000000 00101110 unbound-var   C_SCHEME_UNBOUND
00000000 00000000 00000000 00111110 value=#!eof   C_SCHEME_END_OF_FILE
@end example

This list is exhaustive: currently there are only four special objects.  There is a lot of room for
adding other special objects, if that ever becomes necessary.

The ``unbound variable'' representation cannot be captured by a program: when it is evaluated, it
immediately raises an exception; this is its intended function.

The constants: @code{C_SCHEME_END_OF_LIST}, @code{C_SCHEME_UNDEFINED}, @code{C_SCHEME_UNBOUND},
@code{C_SCHEME_END_OF_FILE} are preprocessor symbols defined at the C language level, in the header
file @file{chicken.h}.

@c page
@node layout blocks
@section Block objects


Block objects are represented by a pointer to a C language structure with a header and a data block;
slightly simplified, it looks like this:

@example
#define C_uword  unsigned C_word
#define C_header C_uword

typedef struct
@{
  C_header header;
  C_word data[];    /* Variable-length array: header determines length */
@} C_SCHEME_BLOCK;
@end example

The header's bit pattern is broken up into three parts:

The representation in machine words uses the least significant byte:

@example
XXXXYYYY ZZZZZZZZ ZZZZZZZZ ZZZZZZZZ
 GC type size of object (slot or byte count)
@end example

@noindent
this is the meaning of the bit groups:

@itemize
@item
The bottom 24 bits encode the size of the object.  On 64-bit machines, the bottom 56 bits are used
for the size.

@item
The middle 4 bits encode the type of the object.

@item
The top 4 bits encode special properties to make the garbage collector's work easier:

@table @code
@item C_GC_FORWARDING_BIT
@cindex @code{C_GC_FORWARDING_BIT}, preprocessor constant
@cindex Preprocessor constant @code{C_GC_FORWARDING_BIT}
Indicates this object has been forwarded elsewhere.  To find the object at its new location, the
entire header is shifted to the left (which shifts out this bit).  Then, the value is reinterpreted
as a pointer.  Remember, the lowest two bits of word pointers are always zero, so we can do this
with impunity!

@item C_BYTEBLOCK_BIT
@cindex @code{C_BYTEBLOCK_BIT}, preprocessor constant
@cindex Preprocessor constant @code{C_BYTEBLOCK_BIT}
Indicates this is a byte blob (size bits are interpreted in bytes, not words).

@item C_SPECIALBLOCK_BIT
@cindex @code{C_BYTEBLOCK_BIT}, preprocessor constant
@cindex Preprocessor constant @code{C_BYTEBLOCK_BIT}
Indicates that the first slot is special and should be skipped by the garbage collector.

@item C_8ALIGN_BIT
@cindex @code{C_BYTEBLOCK_BIT}, preprocessor constant
@cindex Preprocessor constant @code{C_BYTEBLOCK_BIT}
Indicates that for this object, alignment must be maintained at an 8-byte boundary.
@end table
@end itemize

The type bits are assigned incrementally.  There is room for 16 types, only 2 of which are currently
unused.  Let's look at the definitions, which should also help to explain the practical use of the
latter 3 GC bits:

@example
#define C_SYMBOL_TYPE            (0x01000000L)
#define C_STRING_TYPE            (0x02000000L | C_BYTEBLOCK_BIT)
#define C_PAIR_TYPE              (0x03000000L)
#define C_CLOSURE_TYPE           (0x04000000L | C_SPECIALBLOCK_BIT)
#define C_FLONUM_TYPE            (0x05000000L | C_BYTEBLOCK_BIT | C_8ALIGN_BIT)
/*      unused                   (0x06000000L ...) */
#define C_PORT_TYPE              (0x07000000L | C_SPECIALBLOCK_BIT)
#define C_STRUCTURE_TYPE         (0x08000000L)
#define C_POINTER_TYPE           (0x09000000L | C_SPECIALBLOCK_BIT)
#define C_LOCATIVE_TYPE          (0x0a000000L | C_SPECIALBLOCK_BIT)
#define C_TAGGED_POINTER_TYPE    (0x0b000000L | C_SPECIALBLOCK_BIT)
#define C_LAMBDA_INFO_TYPE       (0x0d000000L | C_BYTEBLOCK_BIT)
/*      unused                   (0x0e000000L ...) */
#define C_BUCKET_TYPE            (0x0f000000L)
@end example

Most of the types should be self--explanatory to a seasoned Schemer, but a few things deserve
further explanation.

@itemize
@item
In the STRING type tag, @code{C_BYTEBLOCK_BIT} is also set, for obvious reasons: strings do not
consist of slots containing Scheme values, but of bytes, which are opaque.  Because the header's
size bits store the length in bytes instead of in words, we can spot a very important limitation:
@chicken{} strings can only hold 16 MiB of data on a 32-bit machine (on a 64-bit machine, strings
are ``limited'' to 65536 TiB).

@item
The @code{CLOSURE} type uses @code{C_SPECIALBLOCK_BIT}.  This indicates to the garbage collector
that the first slot contains a raw non--Scheme value.  In the case of a closure, it contains a
pointer to a C function.  The other slots contain free variables that were closed over
(``captured'') by the lambda, which are normal Scheme objects.  The compiled C function ``knows''
which variable lives in which slot.

@item
The @code{FLONUM} type uses @code{C_BYTEBLOCK_BIT}, because an unboxed C @code{double} value is not
a Scheme object: we want to treat the data as an opaque blob.  On a 32-bit system, the @code{double}
will take up two machine words, so we can't use @code{C_SPECIALBLOCK_BIT}.  The header will
therefore hold the value 8 as its size.  It also has another GC bit: @code{C_8ALIGN_BIT}.  This
ensures that the 64-bit @code{double} is aligned on a 8-byte boundary, to avoid unaligned access on
32-bit systems.  This adds some complexity to garbage collection and memory allocation.

@item
The @code{STRUCTURE} type refers to a @ansrfi{9} type of record object.  Its slots hold the record's
fields, and the accessors and constructors ``know'' which field is stored at which index.

@item
The @code{POINTER} type holds a raw C pointer inside a Scheme object.  Again, because C pointers are
not Scheme objects, the object's first (and only) slot is treated specially, via @code{C_SPECIALBLOCK_BIT}.

@item
The @code{LOCATIVE} type represents a rather complicated object.  It acts a bit like a pointer into
a slab of memory.  You can use it as a single value which represents a location inside another block
object.  This can then be used as an argument to a foreign function that expects a pointer.  Its
first slot holds a raw pointer.  The other slots hold the offset, the type of pointer (encoded as
fixnum) and the original object, unless it is a weak reference.

@item
The @code{TAGGED_POINTER} type is exactly like @code{POINTER}, but it has an extra user--defined
tag.  This can make it easier for code to identify the pointer's type.  The tag is a Scheme value
held in its second slot.

@item
The @code{LAMBDA_INFO} type stores procedure introspection information (mostly for debugging).

@item
The @code{BUCKET} type is a special internal pair--like object which is used in the linked list of
symbols under a hash table bucket in the symbol table.  It does not count as a reference, so that
symbols can be garbage collected when only the symbol table still refers to them.
@end itemize

So far, the only numeric types we've seen are fixnums and flonums.  What about the other numeric
types?  After all, @chicken{} 5 has a full numeric tower!

In @chicken{} 5, rational and complex numbers are viewed as two simpler numbers stuck together.
They're stored as records with a special tag, which the runtime system recognises.  Bignums are also
represented as a record with a special tag and a slot that refers to the byte blob containing the
actual bignum value.

@c page
@node checks
@chapter Checking the result of expressions


Some system operations implement assertions against the result of expressions: if the result
satisfies a predicate, nothing happens; otherwise an exception is raised.

@menu
* checks types::                Checking value types.
* checks unsafe::               Including/excluding checks.
@end menu

@c page
@node checks types
@section Checking value types


@macro DefineCheckSystemOperation{SysopName,ValueType}
@deffn {System Operation} {\SysopName\} @qvar{OBJ}
@deffnx {System Operation} {\SysopName\} @qvar{OBJ} @qvar{LOC}
Check if @qvar{OBJ} is a \ValueType\.  When successful: just return unspecified values.  Otherwise
raise an exception of kind @code{(exn type)} using the optional argument @qvar{LOC} as
exceptional--condition @code{location} property.
@end deffn
@end macro

@c ------------------------------------------------------------------------

@DefineCheckSystemOperation{##sys#check-blob, blob}


@DefineCheckSystemOperation{##sys#check-byte-vector, bytevector}


@DefineCheckSystemOperation{##sys#check-pair, pair}


@DefineCheckSystemOperation{##sys#check-list, list}


@DefineCheckSystemOperation{##sys#check-string, string}


@DefineCheckSystemOperation{##sys#check-number, number}


@DefineCheckSystemOperation{##sys#check-fixnum, fixnum}


@DefineCheckSystemOperation{##sys#check-exact, exact number}


@DefineCheckSystemOperation{##sys#check-inexact, inexact number}


@DefineCheckSystemOperation{##sys#check-symbol, symbol}


@DefineCheckSystemOperation{##sys#check-vector, vector}


@DefineCheckSystemOperation{##sys#check-char, character}


@DefineCheckSystemOperation{##sys#check-boolean, boolean}


@DefineCheckSystemOperation{##sys#check-locative, locative}


@DefineCheckSystemOperation{##sys#check-integer, integer}


@DefineCheckSystemOperation{##sys#check-exact-integer, exact integer}


@DefineCheckSystemOperation{##sys#check-exact-uinteger, exact unsigned integer}


@DefineCheckSystemOperation{##sys#check-real, real number}


@c FIXME What does this do?  Really?  (Marco Maggi; May 15, 2019)
@c
@c @DefineCheckSystemOperation{##sys#check-special, special value}


@DefineCheckSystemOperation{##sys#check-closure, closure}


@deffn {System Operation} {##sys#check-structure} @qvar{OBJ} @qvar{NAME} @qvar{LOC}
Check if @qvar{OBJ} is a structure with name @func{eq?} to @qvar{NAME}; @ref{structs, Low--level
structures}.  When successful: just return unspecified values.  Otherwise raise an exception with
kind @code{(exn type)} using the value @qvar{LOC} as exceptional--condition @code{location}
property.
@end deffn


@deffn {System Operation} {##sys#check-range} @qvar{IDX} @qvar{FROM} @qvar{TO} @qvar{LOC}
Check that @qvar{IDX} is a fixnum; if it is not: raise an exception with kind @code{(exn type)}
using the value @qvar{LOC} as exceptional--condition @code{location} property.

Then check if the fixnum @qvar{IDX} is: greater than or equal to @var{FROM} and less than @var{TO};
the arguments @qvar{FROM} and @qvar{TO} must be fixnums.  When successful: just return unspecified
values.  Otherwise raise an exception of kind @code{(exn bounds)} using the value @qvar{LOC} as
exceptional--condition @code{location} property.
@end deffn

@c page
@node checks unsafe
@section Including/excluding checks


If we want to support compilation of unsafe code, we can wrap a use of these operations into a
@func{##core#check} form:

@example
(##core#check (##sys#check-list @qvar{OBJ} @qvar{LOC}))
@end example

@noindent
with normal compilation: the use of @func{##sys#check-list} is included; with unsafe compilation:
the whole form is excluded and replaced with an expression returning @true{}.

@c page
@node slots
@chapter Slots operations


A @dfn{slot} is a machine word in a Scheme value represented as block, whose value is either an
immediate Scheme value or a reference to a block Scheme value; @ref{layout intro block, Block
values}.

@menu
* slots sysops::                System operations on slots.
* slots pairs::                 Slots operations for pairs.
* slots vectors::               Slots operations for vectors.
* slots records::               Slots operations for records.
@end menu

@c page
@node slots sysops
@section System operations on slots


We can access the internal representation of all the compound Scheme values implemented as
``blocks'' with the following system operations.


@deffn {System Operation} {##sys#slot} @qvar{block-value} @qvar{slot-index}
Unsafe slot getter.  We can use it when we know that: @qvar{block-value} is a reference to a block
value; @qvar{slot-index} is a valid slot index for @qvar{block-value}.  Return the undefined value.
@end deffn


@deffn {System Operation} {##sys#setslot} @qvar{block-value} @qvar{slot-index} @qvar{new-value}
Unsafe slot setter.  We can use it when we know that: @qvar{block-value} is a reference to a block
value; @qvar{slot-index} is a valid slot index for @qvar{block-value}.  Return the undefined value.
@end deffn


@deffn {System Operation} {##sys#setislot} @qvar{block-value} @qvar{slot-index} @qvar{new-immediate-value}
Like @syntax{##sys#setslot}, it is an unsafe slot setter with an additional constraint on the new
value.  We can use it when we know that: @qvar{block-value} is a reference to a block value;
@qvar{slot-index} is a valid slot index for @qvar{block-value}; @qvar{new-immediate-value} is any
immediate Scheme value (examples: a fixnum, a boolean).  Return the undefined value.

@strong{NOTE} No validation is performed against @qvar{new-immediate-value} to check that it is
actually an immediate value.
@end deffn


@deffn {System Operation} {##sys#size} @qvar{block-value}
Unsafe block length getter: return a fixnum representing the number of slots.  We can use it when we
know that: @qvar{block-value} is a reference to a block value.
@end deffn

@c page
@node slots pairs
@section Slots operations for pairs


When the block value is a Scheme pair, we could make a more descriptive use of the system operations
with the following macros:

@lisp
(define-syntax-rule ($car ?pair)
  (##sys#slot ?pair 0))

(define-syntax-rule ($cdr ?pair)
  (##sys#slot ?pair 1))

(define-syntax-rule ($car-set! ?pair ?new-value)
  (##sys#setslot ?pair 0 ?new-value))

(define-syntax-rule ($cdr-set! ?pair ?new-value)
  (##sys#setslot ?pair 1 ?new-value))

(define-syntax-rule ($car-set-immediate! ?pair ?new-value)
  (##sys#setislot ?pair 0 ?new-value))

(define-syntax-rule ($cdr-set-immediate! ?pair ?new-value)
  (##sys#setislot ?pair 1 ?new-value))

(define-syntax-rule ($pair-size ?pair)
  (##sys#size ?pair))

($pair-size '(a . b))           @result{} 2

(let ((P (cons 'a 'b)))
  (values ($car P)
          ($cdr P)))
@result{} a b

(let ((P (cons 'a 'b)))
  ($car-set! P 'x)
  ($cdr-set! P 'y)
  (values ($car P)
          ($cdr P)))
@result{} x y

(let ((P (cons 'a 'b)))
  ($car-set-immediate! P 88)
  ($cdr-set-immediate! P 99)
  (values ($car P)
          ($cdr P)))
@result{} 88 99
@end lisp

@c page
@node slots vectors
@section Slots operations for vectors


When the block value is a Scheme vector, we could make a more descriptive use of the system
operations with the following macros:

@lisp
(define-syntax-rule ($vector-ref ?vector ?slot-index)
  (##sys#slot ?vector ?slot-index))

(define-syntax-rule ($vector-set! ?vector ?slot-index ?new-value)
  (##sys#setslot ?vector ?slot-index ?new-value))

(define-syntax-rule ($vector-set-immediate! ?vector ?slot-index ?new-value)
  (##sys#setislot ?vector ?slot-index ?new-value))

(define-syntax-rule ($vector-length ?vector)
  (##sys#size ?vector))

(define V
  (vector 'a 'b 'c))

($vector-set! vec 0 'x)
($vector-set! vec 1 'y)
($vector-set! vec 2 'z)

($vector-ref vec 0)     @result{} x
($vector-ref vec 1)     @result{} y
($vector-ref vec 2)     @result{} z
@end lisp

@c page
@node slots records
@section Slots operations for records


When the block value is a Scheme record, we could make a more descriptive use of the system
operations with the following macros:

@lisp
(define-syntax-rule ($struct-size ?stru)
  (##sys#size ?stru))

(define-syntax-rule ($struct-slot ?stru ?slot-index)
  (##sys#slot ?stru ?slot-index))

(define-syntax-rule ($struct-slot-set! ?stru ?slot-index ?new-value)
  (##sys#setslot ?stru ?slot-index ?new-value))

(define-syntax-rule ($struct-slot-set-immediate! ?stru ?slot-index ?new-value)
  (##sys#setislot ?stru ?slot-index ?new-value))

(define-record <spiffy>
  one two)

(define instance
  (make-<spiffy> 'a 'b))

($struct-size instance)         @result{} 3

($struct-slot instance 0)       @result{} current-module-name#<spiffy>
($struct-slot instance 1)       @result{} a
($struct-slot instance 2)       @result{} b

($struct-slot-set! instance 1 'x)
($struct-slot-set! instance 2 'y)

($struct-slot instance 1)       @result{} x
($struct-slot instance 2)       @result{} y
@end lisp

@c page
@node structs
@chapter Low--level structures


A number of system operations implement the low--level structure value handling.  A structure is a
block Scheme value whose data area is made of machine words holding either immediate Scheme values
or references to block Scheme values; @ref{layout intro block, Block values}.  We can access the
slots of a structure with the slots system operations; @ref{slots, Slots operations}.

@menu
* structs sysops::              System operations on structures.
* structs sample::              Example of structure handling @api{}.
@end menu

@c page
@node structs sysops
@section System operations on structures


@deffn {System Operation} {##sys#make-structure} @qvar{NAME} @qvar{slot-value} @dots{}
Build and return an new structure whose ``name'' is the symbol @qvar{NAME}; initialise the slots
with the Scheme values @qvar{slot-value}.  No validation is performed on the type of values and
their number.
@end deffn


@deffn {System Operation} {##sys#structure?} @qvar{OBJ} @qvar{NAME}
Return @true{} if @qvar{OBJ} is a structure with name @func{eq?} to @qvar{NAME}; otherwise return
@false{}.
@end deffn

@c page
@node structs sample
@section Example of structure handling @api{}


The code below shows how we could define a public @api{} to handle structures:

@lisp
(define-syntax-rule (make-<colour> ?red ?green ?blue)
  (##sys#make-structure '<colour> ?red ?green ?blue))

(define-syntax-rule (colour? ?obj)
  (##sys#structure? ?obj '<colour>))

(define-syntax-rule (check-colour ?obj ?loc)
  (##core#check
   (##sys#check-structure ?obj '<colour> (quote ?loc))))

(define-syntax-rule (colour-red ?stru)
  (check-colour ?stru 'colour-red)
  (##sys#slot ?stru 1))

(define-syntax-rule (colour-green ?stru)
  (check-colour ?stru 'colour-green)
  (##sys#slot ?stru 2))

(define-syntax-rule (colour-blue ?stru)
  (check-colour ?stru 'colour-blue)
  (##sys#slot ?stru 3))

(define-syntax-rule (colour-red-set! ?stru ?new-red-value)
  (check-colour ?stru 'colour-red)
  (##sys#setslot ?stru 1 ?new-red-value))

(define-syntax-rule (colour-green-set! ?stru ?new-green-value)
  (check-colour ?stru 'colour-green)
  (##sys#setslot ?stru 2 ?new-green-value))

(define-syntax-rule (colour-blue-set! ?stru ?new-blue-value)
  (check-colour ?stru 'colour-blue)
  (##sys#setslot ?stru 3 ?new-blue-value))
@end lisp

@noindent
here are some usage examples:

@lisp
(let ((col (make-<colour> 0.2 0.3 0.4)))
  (check-colour col 'here)
  (##sys#slot col 0))
@result{} <colour>

(colour? (make-<colour> 0.2 0.3 0.4)))  @result{} #t
(colour? "ciao"))                       @result{} #f

(let ((col (make-<colour> 0.2 0.3 0.4)))
  (values (colour-red   col)
          (colour-green col)
          (colour-blue  col)))
@result{} 0.2 0.3 0.4

(let ((col (make-<colour> 0.2 0.3 0.4)))
  (colour-red-set!   col 0.5)
  (colour-green-set! col 0.6)
  (colour-blue-set!  col 0.7)
  (values (colour-red   col)
          (colour-green col)
          (colour-blue  col)))
@result{} 0.5 0.6 0.7
@end lisp

@c page
@node procs
@chapter Handling procedure objects


@menu
* procs decoration::            Decorating a procedure object.
@end menu

@c page
@node procs decoration
@section Decorating a procedure object


@cindex decorations block, procedure objects
@cindex Procedure objects, decorations block


@chicken{} allows us to associate a number of values to a procedure object, storing them in the
procedure object itself, which is a block object similar to a Scheme vector; the maximum number of
decorations approaches the maximum length of a Scheme vector.  When adding a decoration value: we
must make sure that we can identify it by applying a predicate to it.


@deffn {System Operation} {##sys#lambda-decoration} @var{proc} @var{pred}
Iterate over the decoration slots of the procedure object @var{proc} searching for a decoration
value that matches the predicate @var{pred}.  If a match is found: return that value; otherwise
return @false{}.
@end deffn


@deffn {System Operation} {##sys#decorate-lambda} @var{proc} @var{pred} @var{decorator}
Iterate over the decoration slots of the procedure object @var{proc} searching for a decoration
value that matches the predicate @var{pred}:

@itemize
@item
If a matching decoration value is found: apply the function @var{decorator} to two values, the
procedure object itself and the index of the slot in which the matching decoration value is stored.

@item
If no matching decoration value is found: @strong{reallocate the procedure object} adding a new
slot, available for this call and left uninitialised.  Then apply the function @var{decorator} to
two values: the new procedure object; the index of the new slot.
@end itemize

Return the values returned by the @var{decorator} application.  @var{decorator} should return the
procedure object it received as argument, because, in case of reallocation, that value is the
replacement of @var{proc}; we have to assume @var{proc} itself is no more a valid Scheme object
after a call to this system operation.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Keyed pair as decoration value


Let's define an @api{} to decorate procedure objects, the decoration value is a pair object with a
``type symbol'' as car:

@lisp
(define MY_PROCEDURE_DECORATION_KEY
  'Sau0oosh8coodahthoa4Ohquic6oshoh)

(define (make-my-procedure-decoration-value proc)
  ;;Build a new decoration value.
  ;;
  (cons MY_PROCEDURE_DECORATION_KEY proc))

(define (my-procedure-decoration-value? obj)
  ;;Return #t if OBJ is a decoration value; otherwise return #f.
  ;;
  (and (pair? obj)
       (eq? MY_PROCEDURE_DECORATION_KEY (car obj))))

(define (decorate-my-procedure proc decoration-value-payload)
  ;;Decorate the procedure PROC with a new payload value.  Return
  ;;the, possibly reallocated, procedure object.
  ;;
  (##sys#decorate-lambda proc my-procedure-decoration-value?
    (lambda (new-proc slotidx)
      (##sys#setslot new-proc slotidx
                     (make-my-procedure-decoration-value
                        decoration-value-payload))
      new-proc)))

(define (my-procedure-decoration-payload proc)
  ;;Retrieve the payload from the decoration value associated to
  ;;the procedure object PROC.  Raise an error if no such decoration
  ;;is present.
  ;;
  (cond ((##sys#lambda-decoration proc my-procedure-decoration-value?)
         => cdr)
        (else
         (error 'my-procedure-decoration-payload
           "expected procedure object decorated with my payload"
           proc))))
@end lisp

@noindent
now we can decorate procedures as follows:

@lisp
(define (the-proc)
  123)

(set! the-proc (decorate-my-procedure the-proc "ciao"))

(my-procedure-decoration-payload the-proc))
@result{} "ciao"
@end lisp

@noindent
or as follows:

@lisp
(define the-proc
  (decorate-my-procedure
      (lambda ()
        123)
    "ciao"))

(my-procedure-decoration-payload the-proc))
@result{} "ciao"
@end lisp

@c page
@node credits
@appendix Document authors and source material


The core informations about the data representation is mostly a derivative from the web page
``CHICKEN internals: data representation'' by @url{https://wiki.call-cc.org/users/peter-bex, Peter
Bex} which is licensed under @url{https://creativecommons.org/licenses/by/3.0/, CC BY 3.0} (@aurl{}
last verified May 14, 2019):

@center @url{https://www.more-magic.net/posts/internals-data-representation.html}

@noindent
it was reformatted and edited from the original @sc{html}; the section about the garbage collector
was dropped.  Some editing had the purpose of making it feel less like a weblog and more like
software documentation.

@c page
@node references
@appendix Bibliography and references


This document is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
@chicken{} can be downloaded from:

@center @url{http://www.call-cc.org/}

The @chicken{} Wiki has a page about data representation:

@center @url{http://wiki.call-cc.org/man/5/Data%20representation}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function

@printindex fn

@node variable index
@appendix An entry for each variable

@printindex vr

@node type index
@appendix An entry for each type

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c ispell-local-dictionary: "en_GB-ise-w_accents"
@c end:
