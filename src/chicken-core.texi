\input texinfo.tex
@c %**start of header
@setfilename chicken-core.info
@settitle @sc{mmck} @sc{chicken} Core
@c %**end of header

@include vers-chicken-core.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Core documentation for @sc{chicken}

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @sc{mmck} @sc{chicken} Docs

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmck-chicken-docs

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2019

@set CHICKEN_VERSION            5.1.0

@c ------------------------------------------------------------

@set GithubUrl                  @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl                @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl           @url{https://marcomaggi.github.io/docs/chicken-core.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro mmck{}
@sc{mmck}
@end macro

@macro chicken{}
@sc{chicken}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes the core Application Programming Interface of @chicken{} version
@value{CHICKEN_VERSION}, it was last updated @value{UPDATED}; this document is part of
@value{PACKAGE}, a collection of unofficial documentation about the @chicken{} compiler and its
development ecosystem.  @chicken{} is a Scheme--to--C compiler supporting the language features as
defined in the ``Revised^5 Report on Scheme''.

Most of this document is a reorganisation of the official @chicken{} documentation.

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* chicken-core: (chicken-core). Core documentation for @chicken{}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* blob::                        Module @library{chicken blob}.
* condition::                   Module @library{chicken condition}.
* continuation::                Module @library{chicken continuation}.

Appendices

* document license::            Document License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes the core Application Programming Interface of @chicken{} version
@value{CHICKEN_VERSION}, it was last updated @value{UPDATED}; this document is part of
@value{PACKAGE}, a collection of unofficial documentation about the @chicken{} compiler and its
development ecosystem.  @chicken{} is a Scheme--to--C compiler supporting the language features as
defined in the ``Revised^5 Report on Scheme''.

@c page
@node blob
@chapter Module @library{chicken blob}


@c page
@node condition
@chapter Module @library{chicken condition}


This module provides various procedures and special forms for raising and handling exceptions with
``condition objects''.  Condition objects provide a structured and composable way to encode the kind
of exception that took place, and provide the necessary context.

@chicken{}'s exception handling is based on the @ansrfi{12}
(@url{http://srfi.schemers.org/srfi-12/srfi-12.html}) exception system.  This chapter contains the
core of the @ansrfi{12} spec as well as @chicken{} implementation specifics.

There is also a @code{srfi-12} or @library{srfi 12} module which only includes the standard
procedures and macros from the @srfi{} document, without the @chicken{} extensions.
@library{chicken condition} offers the complete set of procedures and macros, both
@chicken{}--specific and standard @ansrfi{12}.

@menu
* condition srfi-12::           @ansrfi{12} specification.
* condition chicken::           @chicken{} implementation.
@end menu

@c page
@node condition srfi-12
@section @ansrfi{12} specification


A Scheme implementation (``the system'') raises an exception whenever an error is to be signalled or
whenever the system determines that evaluation cannot proceed in a manner consistent with the
semantics of Scheme.  A program may also explicitly raise an exception.

Whenever the system raises an exception, it invokes the current exception handler with a condition
object (encapsulating information about the exception) as its only argument.  Any procedure
accepting one argument may serve as an exception handler.  When a program explicitly raises an
exception, it may supply any object to the exception handler.

An exception is either continuable or non--continuable.  When the current exception handler is
invoked for a continuable exception, the continuation uses the handler's result(s) in an
exception--specific way to continue.  When an exception handler is invoked for a non--continuable
exception, the continuation raises a non--continuable exception indicating that the exception
handler returned.  On @chicken{}, system error exceptions (of kind @code{exn}) are non--continuable.

@menu
* condition srfi-12 handlers::  Exception handlers.
* condition srfi-12 raising::   Raising exceptions.
* condition srfi-12 condition:: Condition objects.
* condition srfi-12 examples::  More examples.
@end menu

@c page
@node condition srfi-12 handlers
@subsection Exception handlers


@deffn Parameter current-exception-handler
@deffnx Parameter current-exception-handler @var{procedure}
Set or return the current exception handler, a procedure of one argument, the exception object.
@end deffn


@defun with-exception-handler @var{handler} @var{thunk}
Return the result(s) of invoking @var{thunk}.  The @var{handler} procedure is installed as the
current exception handler in the dynamic context of invoking @var{thunk}.

Example:

@lisp
(call-with-current-continuation
   (lambda (k)
     (with-exception-handler
         (lambda (x)
           (k '()))
       (lambda ()
         (car '())))))
@result{} ()
@end lisp

Note that the handler procedure must somehow return non-locally out of the dynamic extent of the
@func{with-exception-handler} form, because returning normally will signal yet another exception and
thus result in non-termination.
@end defun


@deffn Syntax handle-exceptions @qvar{var} @qvar{handle-expr} @qvaro{expr} @qvar{expr} @dots{}
Evaluate the body expressions @qvar{expr} in sequence with an exception handler constructed from
@qvar{var} and @qvar{handle-expr}.  Assuming no exception is raised, the result(s) of the last body
expression is(are) the result(s) of the @syntax{handle-exceptions} expression.

The exception handler created by @syntax{handle-exceptions} restores the dynamic context
(continuation, exception handler, etc.) of the @syntax{handle-exceptions} expression, and then
evaluates @qvar{handle-expr} with @qvar{var} bound to the value provided to the handler.

Examples:

@lisp
(handle-exceptions exn
    (begin
      (display "Went wrong")
      (newline))
  (car '()))
@print{} "Went wrong"

(handle-exceptions exn
    (cond ((eq? exn 'one)
           1)
          (else
           (abort exn)))
  (case (random 3)
    ((0)        'zero)
    ((1)        (abort 'one))
    (else       (abort "Something else"))))
@end lisp
@end deffn

@c page
@node condition srfi-12 raising
@subsection Raising exceptions


@defun abort @var{obj}
Raises a non--continuable exception represented by @var{obj}.  The @func{abort} procedure can be
implemented as follows:

@lisp
(define (abort obj)
  ((current-exception-handler) obj)
  (abort
    (make-property-condition 'exn
      'message "Exception handler returned")))
@end lisp

The `abort` procedure does not ensure that its argument is a condition.  If its argument is a
condition: `abort` does not ensure that the condition indicates a non-continuable exception.
@end defun


@defun signal @var{obj}
Raise a continuable exception represented by @var{obj}.  The @func{signal} procedure can be
implemented as follows:

@lisp
(define (signal exn)
  ((current-exception-handler) exn))
@end lisp

The @func{signal} procedure does not ensure that its argument is a condition.  If its argument is a
condition: @func{signal} does not ensure that the condition indicates a continuable exception.
@end defun

@c page
@node condition srfi-12 condition
@subsection Condition objects


@defun condition? @var{obj}
Return @true{} if @var{obj} is a condition, otherwise returns @false{}.  If any of the predicates
listed in Section 3.2 of the @rnrs{5} is true of @var{obj}, then @func{condition?} is false of
@var{obj}.

Rationale: Any Scheme object may be passed to an exception handler.  This would cause ambiguity if
conditions were not disjoint from all of Scheme's standard types.
@end defun


@defun make-property-condition @var{kind-key} @var{prop-key} @var{value} @dots{}
This procedure accepts any even number of arguments after @var{kind-key}, which are regarded as a
sequence of alternating @var{prop-key} and @var{value} objects.  Each @var{prop-key} is regarded as
the name of a property, and each @var{value} is regarded as the value associated with the @var{key}
that precedes it.  Return a @var{kind-key} condition that associates the given @var{prop-key}s with
the given @var{value}s.
@end defun


@defun make-composite-condition @var{condition} @dots{}
Return a newly--allocated condition whose components correspond to the given @var{condition}s.  A
predicate created by @func{condition-predicate} returns true for the new condition if and only if it
returns true for one or more of its component conditions.
@end defun


@defun condition-predicate @var{kind-key}
Return a predicate that can be called with any object as its argument.  Given a condition that was
created by @func{make-property-condition}, the predicate returns @true{} if and only if
@var{kind-key} is @func{eqv?} to the kind key that was passed to @func{make-property-condition}.
Given a composite condition created with @func{make-composite-condition}, the predicate returns
@true{} if and only if the predicate returns @true{} for at least one of its components.
@end defun


@defun condition-property-accessor @var{kind-key} @var{prop-key}
@defunx condition-property-accessor @var{kind-key} @var{prop-key} @var{default}
Return a procedure that can be called with any condition that satisfies:

@lisp
(condition-predicate @var{kind-key})
@end lisp

Given a condition that was created by @func{make-property-condition} and @var{kind-key}, the
procedure returns the value that is associated with @var{prop-key}.  Given a composite condition
created with @func{make-composite-condition}, the procedure returns the value that is associated
with @var{prop-key} in one of the components that satisfies:

@lisp
(condition-predicate @var{kind-key})
@end lisp

On @chicken{}, this procedure accepts an optional third argument @var{default}.  If the condition
does not have a value for the desired property and if the optional argument is given, no error is
signalled and the accessor returns the third argument.

When the system raises an exception, the condition it passes to the exception handler includes the
@code{exn} kind with the following properties:

@table @code
@item message
@cindex Condition property @code{message}
@cindex @code{message}, condition property
The error message.

@item arguments
@cindex Condition property @code{arguments}
@cindex @code{arguments}, condition property
The arguments passed to the exception handler.

@item location
@cindex Condition property @code{location}
@cindex @code{location}, condition property
The name of the procedure where the error occurred (if available).
@end table

Thus, if @var{exn} is a condition representing a system exception, then:

@lisp
((condition-property-accessor 'exn 'message) exn)
@end lisp

@noindent
extracts the error message from @var{exn}.  Example:

@lisp
(handle-exceptions exn
    (begin
      (display "Went wrong: ")
      (display ((condition-property-accessor 'exn 'message) exn))
      (newline))
  (car '()))
; displays something like "Went wrong: can't take car of nil"
@end lisp
@end defun

@c page
@node condition srfi-12 examples
@subsection More examples


@lisp
  (define (try-car v)
   (let ((orig (current-exception-handler)))
     (with-exception-handler
      (lambda (exn)
        (orig (make-composite-condition
             (make-property-condition
              'not-a-pair
              'value
              v)
             exn)))
      (lambda () (car v)))))

  (try-car '(1))
  ;=> 1

  (handle-exceptions exn
                   (if ((condition-predicate 'not-a-pair) exn)
                       (begin
                        (display "Not a pair: ")
                        (display
                         ((condition-property-accessor 'not-a-pair 'value) exn))
                        (newline))
                       (abort exn))
    (try-car 0))
  ; displays "Not a pair: 0"

  (let* ((cs-key (list 'color-scheme))
         (bg-key (list 'background))
         (color-scheme? (condition-predicate cs-key))
         (color-scheme-background
        (condition-property-accessor cs-key bg-key))
         (condition1 (make-property-condition cs-key bg-key 'green))
         (condition2 (make-property-condition cs-key bg-key 'blue))
         (condition3 (make-composite-condition condition1 condition2)))
    (and (color-scheme? condition1)
         (color-scheme? condition2)
         (color-scheme? condition3)
         (color-scheme-background condition3)))
  ; => 'green or 'blue
@end lisp

@c page
@node condition chicken
@section @chicken{} implementation


@menu
* condition chicken system::    System conditions.
* condition chicken notes::     Notes.
* condition chicken api::       Additional @api{}.
@end menu

@c page
@node condition chicken system
@subsection System conditions


All error--conditions signaled by the system are of kind @code{exn}.  The following composite
conditions are additionally defined:

@table @code
@item (exn arity)
Signalled when a procedure is called with the wrong number of arguments.

@item (exn type)
Signalled on type--mismatch errors, for example when an argument of the wrong type is passed to a
built--in procedure.

@item (exn arithmetic)
Signalled on arithmetic errors, like division by zero.

@item (exn i/o)
Signalled on input/output errors.

@item (exn i/o file)
Signalled on file--related errors.

@item (exn i/o net)
Signalled on network errors.

@item (exn bounds)
Signalled on errors caused by accessing non--existent elements of a collection.

@item (exn runtime)
Signalled on low--level runtime--system error--situations.

@item (exn runtime limit)
Signalled when an internal limit is exceeded (like running out of memory).

@item (exn match)
Signalled on errors raised by failed matches (see the section on @func{match}).

@item (exn syntax)
Signalled on syntax errors.
@end table

@c page
@node condition chicken notes
@subsection Notes


@itemize
@item
All error--exceptions (of the kind @code{exn}) are non--continuable.

@item
Error--exceptions of the @code{exn} kind have additional @code{arguments} and @code{location}
properties that contain the arguments passed to the exception--handler and the name of the procedure
where the error occurred (if available).

@item
Within the interpreter (@command{csi}), a user--interrupt (@code{signal/int}) signals an exception
of the kind @code{user-interrupt}.

@item
The procedure @func{condition-property-accessor} accepts an optional third argument.  If the
condition does not have a value for the desired property and if the optional argument is given, no
error is signalled and the accessor returns the third argument.

@item
On platforms that support the @cfunc{sigprocmask} @posix{} @api{} function, the signals
@code{SIGSEGV}, @code{SIGFPE}, @code{SIGBUS} and @code{SIGILL} will be caught and trigger an
exception instead of aborting the process, if possible.  If the unwinding and handling of the signal
raises one of these signals once again, the process will abort with an error message.
@end itemize

@c page
@node condition chicken api
@subsection Additional @api{}


@deffn Syntax condition-case @qvar{expression} @qvar{clause} @dots{}
Evaluate @qvar{expression} and handle any exceptions that are covered by @qvar{clause}, where
@qvar{clause} should be of the following form:

@example
@qvar{clause} = ([@qvar{variable}] (@qvar{kind} ...) @qvar{body} ...)
@end example

If provided, @qvar{variable} will be bound to the signalled exception object.  The @qvar{body} forms
are executed when the exception is a property or composite condition with the kinds given
@qvar{kind} (unevaluated).  If no clause applies, the exception is re--signalled in the same dynamic
context as the @syntax{condition-case} form.

@lisp
(define (check thunk)
  (condition-case (thunk)
    ((exn file) (print "file error"))
    ((exn)      (print "other error"))
    (var ()     (print "something else"))))

(check (lambda () (open-input-file "")))   @result{} "file error"
(check (lambda () some-unbound-variable))  @result{} "othererror"
(check (lambda () (signal 99)))            @result{} "something else"

(condition-case some-unbound-variable
  ((exn file) (print "ignored")) )      @error{} signals error
@end lisp
@end deffn


@defun get-condition-property @var{condition} @var{kind} @var{property}
@defunx get-condition-property @var{condition} @var{kind} @var{property} @var{DEFAULT}
A slightly more convenient condition property accessor, equivalent to:

@lisp
((condition-property-accessor @var{kind} @var{property}) @var{condition})
((condition-property-accessor @var{kind} @var{property} [@var{default}]) @var{condition})
@end lisp
@end defun


@defun condition @varo{lst} @var{LST} @dots{}
This is a more convenient constructor for conditions.  Each @var{lst} is a list of the following
form:

@lisp
(@var{kind} @vari{property} @vari{value} @varii{property} @varii{value} ...)
@end lisp

In other words, the following:

@lisp
(signal
  (condition '(exn location foo message "hi")
             '(file bar 1)))
@end lisp

@noindent
is equivalent to the @ansrfi{12} code:

@lisp
(signal
  (make-composite-condition
    (make-property-condition 'exn 'location 'foo 'message "hi")
    (make-property-condition 'file 'bar 2)))
@end lisp
@end defun


@defun condition->list @var{condition}
Convert a condition object into a list holding all the conditions that are represented by the
@var{condition} object.  It is formatted as follows:

@example
((@vari{kind} @vari{property} @vari{value} @varii{property} @varii{value} ...)
 (@varii{kind} ...)
 ...)
@end example

There is no guaranteed order within the list.
@end defun


@defun print-error-message @var{exn}
@defunx print-error-message @var{exn} @var{port}
@defunx print-error-message @var{exn} @var{port} @var{header}
Print an appropriate error message to @var{port} (which defaults to the value of
@code{(current-output-port)} for the object @var{exn}. @var{exn} may be a condition, a string or any
other object.  The output is prefixed by the @var{header}, which defaults to @code{"Error:"}.
@end defun

@c page
@node continuation
@chapter Module @library{chicken continuation}


@c page
@node document license
@appendix Document license


@c page
@node references
@appendix Bibliography and references


This document is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
@chicken{} can be downloaded from:

@center @url{http://www.call-cc.org/}

@noindent
the package @mmck{} Checks is available from:

@center @url{https://github.com/marcomaggi/mmck-checks/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function

@printindex fn

@node variable index
@appendix An entry for each variable

@printindex vr

@node type index
@appendix An entry for each type

@printindex tp

@contents
@bye

@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c ispell-local-dictionary: "en_GB-ise-w_accents"
@c End:
