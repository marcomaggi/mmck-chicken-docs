\input texinfo.tex
@c %**start of header
@setfilename chicken-core.info
@settitle @sc{mmck} @sc{chicken} Core
@c %**end of header

@include vers-chicken-core.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Core documentation for @sc{chicken}

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @sc{mmck} @sc{chicken} Docs

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmck-chicken-docs

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2019

@set CHICKEN_VERSION            5.1.0

@c ------------------------------------------------------------

@set GithubUrl                  @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl                @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl           @url{https://marcomaggi.github.io/docs/chicken-core.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro mmck{}
@sc{mmck}
@end macro

@macro chicken{}
@sc{chicken}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes the core Application Programming Interface of @chicken{} version
@value{CHICKEN_VERSION}, it was last updated @value{UPDATED}; this document is part of
@value{PACKAGE}, a collection of @strong{unofficial} documentation about the @chicken{} compiler and
its development ecosystem.  @chicken{} is a Scheme--to--C compiler supporting the language features
as defined in the ``Revised^5 Report on Scheme''.

Most of this document is a reorganisation and editing of the official @chicken{} documentation.
This document includes the original @rnrs{5} document translated into @gnu{} Texinfo format
(retrieved from the source distribution of @gnu{} Guile).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@chicken{} and its original documentation falls under the following main license:

@noindent
Copyright @copyright{} 2007-2019, The CHICKEN Team@*
Copyright @copyright{} 2000-2007, Felix L. Winkelmann@*
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted
provided that the following conditions are met:

@enumerate
@item
Redistributions of source code must retain the above copyright notice, this list of conditions and
the following disclaimer.

@item
Redistributions in binary form must reproduce the above copyright notice, this list of conditions
and the following disclaimer in the documentation and/or other materials provided with the
distribution.

@item
The name of the authors may not be used to endorse or promote products derived from this software
without specific prior written permission.
@end enumerate

THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* chicken-core: (chicken-core). Core documentation for @chicken{}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* r5rs::                        The Revised(5) Report on Scheme.
* base::                        Module @library{chicken base}.
* blob::                        Module @library{chicken blob}.
* condition::                   Module @library{chicken condition}.
* continuation::                Module @library{chicken continuation}.

Appendices

* document license::            Document License.
* srfi::                        @srfi{}: Scheme Requests For Implementation.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes the core Application Programming Interface of @chicken{} version
@value{CHICKEN_VERSION}, it was last updated @value{UPDATED}; this document is part of
@value{PACKAGE}, a collection of @strong{unofficial} documentation about the @chicken{} compiler and
its development ecosystem.  @chicken{} is a Scheme--to--C compiler supporting the language features
as defined in the ``Revised^5 Report on Scheme''.

Most of this document is a reorganisation and editing of the official @chicken{} documentation.
This document includes the original @rnrs{5} document translated into @gnu{} Texinfo format
(retrieved from the source distribution of @gnu{} Guile).

@c page

@include r5rs.texi

@c page
@node base
@chapter Module @library{chicken base}


@cindex @library{chicken blob} module
@cindex Module @library{chicken blob}


The module @library{chicken base} defines core procedures and macros, acting as basic extensions to
the @rnrs{5} standard and other essential features.

This module is used by default, unless a program is compiled with the @option{-explicit-use} option.

@menu
* base numpred::                Numeric predicates.
* base arithmetic::             Arithmetic.
* base lazy::                   Lazy evaluation.
* base io::                     Input/output.
* base errors::                 Interrupts and error-handling.
* base lists::                  Lists.
* base vectors::                Vectors.
* base combinators::            Combinators.
* base named-chars::            User-defined named characters.
* base void::                   The unspecified value.
* base cont::                   Continuations.
* base symbols::                Symbols.
* base setters::                Setters.
* base optargs::                Binding forms for optional arguments.
* base binds::                  Other binding forms.
* base parms::                  Parameters.
* base inline::                 Substitution forms and macros.
* base cond::                   Conditional forms.
* base records::                Record structures.
* base forms::                  Other forms.
* base libs::                   Making extra libraries and extensions
                                available.
* base process::                Process shutdown.
* base system::                 System interface.
* base ports::                  Ports.
@end menu

@c page
@node base numpred
@section Numeric predicates


These allow you to make a more precise differentiation between number types and their properties,
not provided by @rnrs{5}.


@defun fixnum? @var{X}
Return @true{} if @var{X} is a fixnum, or @false{} otherwise.
@end defun


@defun flonum? @var{X}
Return @true{} if @var{X} is a flonum, or @false{} otherwise.
@end defun


@defun bignum? @var{X}
Return @true{} if @var{X} is a bignum (integer larger than fits in a fixnum), or @false{} otherwise.
@end defun


@defun exact-integer? @var{X}
Return @true{} if @var{X} is an exact integer (i.e., a fixnum or a bignum), or @false{} otherwise.

This procedure is compatible with the definition from the @rnrs{7} @library{scheme base} library.
@end defun


@defun cplxnum? @var{X}
Return @true{} if @var{X} is a true complex number (it has an imaginary component), or @false{}
otherwise.

Note that @func{complex?} will always return @true{} for any number type supported by @chicken{}, so
you can use this predicate if you want to know the representational type of a number.
@end defun


@defun ratnum? @var{X}
Return @true{} if @var{X} is a true rational number (it is a fraction with a denominator that's not
@math{1}), or @false{} otherwise.

Note that @func{rational?} will always return @true{} for any number type supported by @chicken{}
except complex numbers and non--finite flonums, so you can use this predicate if you want to know
the representational type of a number.
@end defun


@defun nan? @var{N}
Return @true{} if @var{N} is not a number (a @ieee{} flonum NaN--value).  If @var{N} is a complex
number, it's considered nan if it has a real or imaginary component that's NaN.

This procedure is compatible with the definition from the @rnrs{7} @library{scheme inexact} library.
@end defun


@defun infinite? @var{N}
Return @true{} if @var{N} is negative or positive infinity, and @false{} otherwise.  If @var{N} is a
complex number, it's considered infinite if it has a real or imaginary component that's infinite.

This procedure is compatible with the definition from the @rnrs{7} @library{scheme inexact} library.
@end defun


@defun finite? @var{N}
Return @true{} if @var{N} represents a finite number and @false{} otherwise.  Positive and negative
infinity as well as NaNs are not considered finite.  If @var{N} is a complex number, it's considered
finite if both the real and imaginary components are finite.

This procedure is compatible with the definition from the @rnrs{7} @library{scheme inexact} library.
@end defun


@defun equal=? @var{X} @var{Y}
Similar to the standard procedure @func{equal?}, but compares numbers using the @func{=} operator,
so @func{equal=?} allows structural comparison in combination with comparison of numerical data by
value.
@end defun

@c page
@node base arithmetic
@section Arithmetic


@defun add1 @var{N}
@defunx sub1 @var{N}
Add/subtract @math{1} from @var{N}.
@end defun


@defun exact-integer-sqrt @var{K}
Return two values @math{s} and @math{r}, where @math{s^2 + r = K} and @math{K < (s+1)^2}.  In other
words, @math{s} is the closest square root we can find that's equal to or smaller than @math{K}, and
@math{r} is the rest if @math{K} isn't a neat square of two numbers.

This procedure is compatible with the definition from the @rnrs{7} @library{scheme base} library.
@end defun


@defun exact-integer-nth-root @var{K} @var{N}
Like @func{exact-integer-sqrt}, but with any base value.  Calculate @math{\sqrt[N]{K}}, the
@var{N}th root of @var{K} and return two values @var{s} and @var{r} where @math{s^N + r = K} and @math{K <
(s+1)^N}.
@end defun


@defun {quotient&remainder} @var{X} @var{Y}
@defunx {quotient&modulo} @var{X} @var{Y}
Return two values: the quotient and the remainder (or modulo) of @var{X} divided by @var{Y}.  Could
be defined as:

@lisp
(values (quotient @var{X} @var{Y}) (remainder @var{X} @var{Y}))
@end lisp

@noindent
but is much more efficient when dividing very large numbers.
@end defun


@defun signum N
For real number, returns @code{1} if @var{N} is positive, @code{-1} if @var{N} is negative or
@code{0} if @var{N} is zero.  @func{signum} is exactness preserving.

For complex numbers, returns a complex number of the same angle but with magnitude @code{1}.
@end defun

@c page
@node base lazy
@section Lazy evaluation


@deffn Syntax delay-force @qvar{expression}
The expression:

@lisp
(delay-force @qvar{expression})
@end lisp

@noindent
is conceptually similar to:

@lisp
(delay (force @qvar{expression}))
@end lisp

@noindent
with the difference that forcing the result of @syntax{delay-force} will in effect result in a tail
call to @code{(force @qvar{expression})}, while forcing the result of @code{(delay (force
@qvar{expression}))} might not.

Thus iterative lazy algorithms that might result in a long series of chains of @func{delay} and
@func{force} can be rewritten using @syntax{delay-force} to prevent consuming unbounded space during
evaluation.

This special form is compatible with the definition from the @rnrs{7} @library{scheme lazy} library.

For a more complete description of delayed evaluation @ref{r5rs control features, Control features}.

For more information regarding the unbounded build-up of space, see the @ansrfi{45} rationale;
@ref{srfi lazy-evaluation}.
@end deffn


@defun make-promise @var{obj}
Return a promise which, when forced, will return @var{obj}.  It is similar to @func{delay}, but does
not delay its argument: it is a procedure rather than syntax.  If @var{obj} is already a promise, it
is returned.

This procedure is compatible with the definition from the @rnrs{7} @library{scheme lazy} library.
@end defun


@defun promise? @var{X}
Return @true{} if @var{X} is a promise returned by @func{delay}, or @false{} otherwise.

This procedure is compatible with the definition from the @rnrs{7} @library{scheme lazy} library.
@end defun

@c page
@node base io
@section Input/Output


@cindex Printing Scheme objects
@cindex Scheme objects, printing
@cindex objects, printing


@defun current-error-port
@defunx current-error-port @var{PORT}
Return default error output port.  If the optional argument @var{PORT} is given, then that port is
selected as the new current error output port.

Note that the default error output port is not buffered.  We can use @func{set-buffering-mode!} to
set a different behaviour.
@end defun


@defun print @var{exp} @dots{}
Output the optional arguments @var{exp} using @func{display} and write a newline character to the
port that is the value of @code{(current-output-port)}.  Return @code{(void)}.
@end defun


@defun print* @var{exp} @dots{}
Similar to @func{print}, but does not output a terminating newline character and performs a
@func{flush-output} after writing its arguments.
@end defun

@c page
@node base errors
@section Interrupts and error-handling


@defun enable-warnings
@defunx enable-warnings @var{bool}
Enable or disable warnings, depending on whether @var{bool} is true or false.  If called with no
arguments, this procedure returns @true{} if warnings are currently enabled, or @false{} otherwise.
Note that this is not a parameter.  The current state (whether warnings are enabled or disabled) is
global and not thread--local.
@end defun


@defun error @var{} @var{exp} @dots{}
@defunx error @var{string} @var{exp} @dots{}
@defunx error @var{symbol} @var{string} @var{exp} @dots{}
Print an error message, write all extra arguments to the value of @code{(current-error-port)} and
invoke the current exception--handler.  This conforms to @ansrfi{23}
(@url{http://srfi.schemers.org/srfi-23/srfi-23.html}).

If the first argument is a symbol: it specifies the @code{location} property of the raised
exceptional--condition object: the name of the procedure where the error occurred.

If the second argument is a string: it specifies the @code{message} property of the raised
exceptional--condition object.

@lisp
(import (scheme) (chicken base) (chicken condition))

(call/cc
    (lambda (escape)
      (with-exception-handler
          (lambda (E)
            (escape
              (list (get-condition-property E 'exn 'location)
                    (get-condition-property E 'exn 'message)
                    (get-condition-property E 'exn 'arguments))))
        (lambda ()
          (error 'me "something wrong" 1 2 3)))))
@result{} (me "something wrong" (1 2 3))
@end lisp
@end defun


@deffn Syntax assert EXP @var{obj} @dots{}
Evaluate @var{EXP}, if it returns @false{}, applies @func{error} on the optional arguments
@var{obj}.  When compiling in unsafe mode, assertions of this kind are disabled.
@end deffn


@defun get-call-chain
@defunx get-call-chain @var{start}
@defunx get-call-chain @var{start} @var{thread}
Return a list with the call history.  Backtrace information is only generated in code compiled
without @option{-no-trace} and evaluated code.  If the optional argument @var{start} is given, the
backtrace starts at this offset, i.e. when @var{start} is 1, the next to last trace--entry is
printed, and so on.  If the optional argument @var{thread} is given, then the call--chain will only
be constructed for calls performed by this thread.
@end defun


@defun print-call-chain
@defunx print-call-chain @var{port}
@defunx print-call-chain @var{port} @var{start}
@defunx print-call-chain @var{port} @var{start} @var{thread}
@defunx print-call-chain @var{port} @var{start} @var{thread} @var{header}
print a backtrace of the procedure call history to @var{port}, which defaults to
@code{(current-output-port)}.  The output is prefixed by the @var{header}, which defaults to:

@example
"\n\tCall history:\n"
@end example
@end defun


@defun procedure-information @var{proc}
Return an s--expression with debug information for the procedure @var{proc}, or @false{}, if
@var{proc} has no associated debug information.
@end defun


@defun warning @var{string} @var{exp} @dots{}
Display a warning message (if warnings are enabled with @func{enable-warnings}) and continues
execution.
@end defun

@c page
@node base lists
@section Lists


@defun alist-ref @var{key} @var{alist}
@defunx alist-ref @var{key} @var{alist} @var{test}
@defunx alist-ref @var{key} @var{alist} @var{test} @var{default}
look up @var{key} in @var{alist} using @var{test} as the comparison function (or @func{eqv?} if no
@var{test} was given) and return the cdr of the found pair, or @var{default} (which defaults to
@false{}).
@end defun


@defun alist-update @var{key} @var{value} @var{alist}
@defunx alist-update @var{key} @var{value} @var{alist} @var{test}
@defunx alist-update! @var{key} @var{value} @var{alist}
@defunx alist-update! @var{key} @var{value} @var{alist} @var{test}
If the list @var{alist} contains a pair of the form:

@example
(@var{key} . @var{x})
@end example

@noindent
then this procedure replaces @var{X} with @var{value} and returns @var{alist}.  If @var{alist}
contains no such item, then @func{alist-update} returns:

@example
((@var{key} . @var{value}) .  @var{alist})
@end example

The optional argument @var{test} specifies the comparison procedure to search a matching pair in
@var{alist} and defaults to @func{eqv?}.  @func{alist-update!} is the destructive version of
@func{alist-update}.
@end defun


@defun atom? @var{X}
Return @true{} if @var{X} is not a pair.
@end defun


@defun butlast @var{list}
Return a fresh list with all elements but the last of @var{list}.
@end defun


@defun chop @var{list} @var{N}
Return a new list of sublists, where each sublist contains @var{n} elements of @var{list}.  If
@var{list} has a length that is not a multiple of @var{N}, then the last sublist contains the
remaining elements.

@lisp
(chop '(1 2 3 4 5 6) 2) @result{} ((1 2) (3 4) (5 6))
(chop '(a b c d) 3)     @result{} ((a b c) (d))
@end lisp
@end defun


@defun compress @var{blist} @var{list}
Return a new list with elements taken from @var{list} with corresponding true values in the list
@var{blist}.

@lisp
(define nums '(99 100 110 401 1234))

(compress (map odd? nums) nums)
@result{} (99 401)
@end lisp
@end defun


@defun flatten @var{list} @dots{}
Return the @var{list} arguments concatenated together, with nested lists removed (flattened).

@lisp
(flatten)               @result{} ()
(flatten '(1))          @result{} (1)
(flatten '(1 (2) 3))    @result{} (1 2 3)

(flatten '((1 2 3) (4) (((5)))))
@result{} (1 2 3 4 5)
@end lisp
@end defun


@defun foldl @var{procedure} @var{init} @var{list}
Apply @var{procedure} to the elements from @var{list}, beginning from the left:

@lisp
(foldl + 0 '(1 2 3))    @result{} (+ (+ (+ 0 1) 2) 3)
@end lisp

Note that the order of arguments taken by @var{procedure} is different from the `@ansrfi{1}`
@func{fold} procedure, but matches the more natural order used in Haskell and Objective Caml.
@end defun


@defun foldr @var{procedure} @var{init} @var{list}
Apply @var{procedure} to the elements from @var{list}, beginning from the right:

@lisp
(foldr + 0 '(1 2 3))    @result{} (+ 1 (+ 2 (+ 3 0)))
@end lisp
@end defun


@defun intersperse @var{list} @var{x}
Return a new list with @var{x} placed between each element.
@end defun


@defun join @var{listoflists}
@defunx join @var{listoflists} @var{list}
Concatenate the lists in @var{listoflists} with @var{list} placed between each sublist.  @var{list}
defaults to the empty list.

@lisp
(join '((a b) (c d) (e))
      '(x y))
@result{} (a b x y c d x y e)

(join '((p q) () (r (s) t))
      '(-))
@result{} (p q - - r (s) t)
@end lisp

@func{join} could be implemented as follows:

@lisp
(define (join lstoflsts #!optional (lst '()))
  (apply append (intersperse lstoflists lst)))
@end lisp
@end defun


@defun rassoc @var{key} @var{list}
@defunx rassoc @var{key} @var{list} @var{test}
Similar to @func{assoc}, but compares @var{key} with the @func{cdr} of each pair in @var{list} using
@var{test} as the comparison procedures (which defaults to @func{eqv?}).
@end defun


@defun tail? @var{x} @var{list}
Return true if @var{x} is one of the tails (cdr's) of @var{list}.
@end defun

@c page
@node base vectors
@section Vectors


@defun vector-copy! @vari{vector} @varii{vector}
@defunx vector-copy! @vari{vector} @varii{vector} @var{count}
Copy contents of @vari{vector} into @varii{VECTOR}.  If the argument @var{count} is given, it
specifies the maximal number of elements to be copied.  If not given, the minimum of the lengths of
the argument vectors is copied.

Exceptions: `(exn bounds)`

This procedure is compatible with the definition from the @rnrs{7} `(scheme base)` library.
@end defun


@defun vector-resize @var{vector} @var{n}
@defunx vector-resize @var{vector} @var{n} @var{init}
Create and return a new vector with the contents of @var{vector} and length @var{N}.  If @var{N} is
greater than the original length of @var{vector}, then all additional items are initialized to
@var{init}.  If @var{init} is not specified: the contents are initialized to some unspecified value.
@end defun


@defun subvector @var{vector} @var{from}
@defunx subvector @var{vector} @var{from} @var{to}
Return a new vector with elements taken from @var{vector} in the given range.  The optional argument
@var{to} defaults to:

@lisp
(vector-length @var{vector})
@end lisp

@noindent
@func{subvector} was introduced in @chicken{} 4.7.3.

Some usage examples, notice the exception raised when the output vector is not big enough:

@lisp
(let ((vec.in     (vector 1 2 3))
      (vec.ou     (make-vector 3 #f)))
  (vector-copy! vec.in vec.ou)
  vec.ou)
@result{} #(1 2 3)

(let ((vec.in     (vector 1 2 3))
      (vec.ou     (make-vector 3 #f)))
  (vector-copy! vec.in vec.ou 2)
  vec.ou)
@result{} #(1 2 #f)

(call/cc
    (lambda (escape)
      (with-exception-handler
          (lambda (E)
            (escape
             (list (get-condition-property E 'exn 'location)
                   (get-condition-property E 'exn 'message)
                   (get-condition-property E 'exn 'arguments))))
        (lambda ()
          (let ((vec.in   (vector 1 2 3))
                (vec.ou   (make-vector 2 #f)))
            (vector-copy! vec.in vec.ou 3)
            vec.ou)))))
@result{} (vector-copy!
    "cannot copy vector - count exceeds length"
    (#(1 2 3) #(#f #f) 3))

(condition-case
    (let ((vec.in (vector 1 2 3))
          (vec.ou (make-vector 2 #f)))
      (vector-copy! vec.in vec.ou 3)
      vec.ou)
  (E (exn bounds)
     (list (get-condition-property E 'exn 'location)
           (get-condition-property E 'exn 'message)
           (get-condition-property E 'exn 'arguments))))
@result{} (vector-copy!
    "cannot copy vector - count exceeds length"
    (#(1 2 3) #(#f #f) 3))
@end lisp
@end defun

@c page
@node base combinators
@section Combinators


@defun constantly @var{x} @dots{}
Return a procedure that always returns the values @var{x} regardless of the number and value of its
arguments.

@lisp
(constantly X) <=> (lambda args X)
@end lisp
@end defun


@defun complement @var{proc}
Return a procedure that returns the boolean inverse of @var{proc}.

@lisp
(complement PROC) <=> (lambda (x) (not (PROC x)))
@end lisp
@end defun


@defun compose @var{proc} @dots{}
Return a procedure that represents the composition of the argument--procedures @var{proc1}.

@lisp
(compose F G) <=> (lambda args
                      (call-with-values
                         (lambda () (apply G args))
                         F))
@end lisp

@code{(compose)} is equivalent to @func{values}.
@end defun


@defun conjoin @var{pred} @dots{}
Return a procedure that returns @true{} if its argument satisfies the predicates @var{pred}.  If no
@var{pred} arguments are given: the returned procedure always returns @true{}.

@lisp
((conjoin) 123)                 @result{} #t
((conjoin odd? positive?) 33)   @result{} #t
((conjoin odd? positive?) -33)  @result{} #f
@end lisp
@end defun


@defun disjoin @var{pred} @dots{}
Return a procedure that returns @true{} if its argument satisfies any predicate @var{pred}.  If no
@var{pred} arguments are given: the returned procedure always returns @false{}.

@lisp
((disjoin) 123)                 @result{} #f
((disjoin odd? positive?) 32)   @result{}  #t
((disjoin odd? positive?) -32)  @result{}  #f
@end lisp
@end defun


@defun each @var{proc} @dots{}
Return a procedure that applies @var{proc} to its arguments, and returns the result(s) of the last
procedure application.  For example:

@lisp
(each pp eval)
@end lisp

@noindent
is equivalent to:

@lisp
(lambda args
  (apply pp args)
  (apply eval args))
@end lisp

@noindent
@code{(each PROC)} is equivalent to @var{proc} and @code{(each)} is equivalent to @code{void}.
@end defun


@defun flip @var{proc}
Return a two--argument procedure that calls @var{proc} with its arguments swapped:

@lisp
(flip @var{proc}) <=> (lambda (x y) (@var{proc} y x))
@end lisp
@end defun


@defun identity @var{x}
Return its sole argument @var{X}.
@end defun


@defun list-of? @var{pred}
Return a procedure of one argument that returns @true{} when applied to a list of elements that all
satisfy the predicate procedure @var{pred}, or @false{} otherwise.

@lisp
((list-of? even?) '(1 2 3))   @result{} #f
((list-of? number?) '(1 2 3)) @result{} #t
@end lisp
@end defun


@defun o @var{proc} @dots{}
A single value version of @func{compose} (slightly faster).  @code{(o)} is equivalent to
@func{identity}.
@end defun

@c page
@node base named-chars
@section User--defined named characters


@defun char-name @var{symbol-or-char}
@defunx char-name @var{symbol-or-char} @var{CHAR}
This procedure can be used to inquire about character names or to define new ones.  With a single
argument the behavior is as follows:

@itemize
@item
If @var{symbol-or-char} is a symbol, then @func{char-name} returns the character with this name, or
@false{} if no character is defined under this name.

@item
If @var{symbol-or-char} is a character, then the name of the character is returned as a symbol, or
@false{} if the character has no associated name.
@end itemize

If the optional argument @var{char} is provided, then @var{symbol-or-char} should be a symbol that
will be the new name of the given character.  If multiple names designate the same character, then
the @func{write} will use the character name that was defined last.

@lisp
(char-name 'space)                  @result{} #\space
(char-name #\space)                 @result{} space
(char-name 'bell)                   @result{} #f
(char-name (integer->char 7))       @result{} #f
(char-name 'bell (integer->char 7))
(char-name 'bell)                   @result{} #\bell
(char->integer (char-name 'bell))   @result{} 7
@end lisp
@end defun

@c page
@node base void
@section The unspecified value


@defun void @var{ARGUMENT} @dots{}
Ignore @var{ARGUMENT} and return an unspecified value.
@end defun

@c page
@node base cont
@section Continuations


@defun call/cc @var{procedure}
An alias for @func{call-with-current-continuation}.

This procedure is compatible with the definition from the @rnrs{7} @library{scheme base} library.
@end defun

@c page
@node base symbols
@section Symbols


@defun symbol-append @var{symbol} @dots{}
Create a new symbol from the concatenated names of the argument symbols @var{symbol}.

@lisp
(symbol-append 'a 'b)           @result{} ab

(eq? (symbol-append) '||)       @result{} #t
@end lisp
@end defun


Symbols may be ``interned'' or ``uninterned''.  Interned symbols are registered in a global table,
and when read back from a port are identical to a symbol written before:

@lisp
(define sym 'foo)

(eq? sym (with-input-from-string
            (with-output-to-string
              (lambda () (write sym)))
            read))
@result{} #t
@end lisp

Uninterned symbols on the other hand are not globally registered and so multiple symbols with the
same name may coexist:

@lisp
;; sym is a uninterned symbol like "foo42"
(define sym (gensym 'foo))

;; the symbol read will be an interned symbol
(eq? sym (with-input-from-string
            (with-output-to-string
              (lambda () (write sym)))
          read))
@result{} #f

(eq? (string->uninterned-symbol "foo")
     (string->uninterned-symbol "foo"))
@result{} #f
@end lisp

Use uninterned symbols if you need to generate unique values that can be compared quickly, for
example as keys into a hash--table or association list.  Note that uninterned symbols lose their
uniqueness property when written to a file and read back in, as in the example above.


@defun gensym @var{string-or-symbol}
@defunx gensym @var{string-or-symbol}
Return a newly created uninterned symbol.  If an argument is provided, the new symbol is prefixed
with that argument.
@end defun


@defun {string->uninterned-symbol} @var{string})
Return a newly created, unique symbol with the name @var{string}.
@end defun

@c page
@node base setters
@section Setters


@ansrfi{17} is fully implemented.  For more information see: @ansrfi{17}
(http://srfi.schemers.org/srfi-17/srfi-17.html).


@menu
* base setters srfi::           @ansrfi{17}: generalised @syntax{set!}.
* base setters ext::            @chicken extensions.
@end menu

@c page
@node base setters srfi
@subsection @ansrfi{17}: generalised @syntax{set!}


@cindex @srfi{} generalised @syntax{set!}

The @ansrfi{17} is by Per Bothner; see:

@center @url{http://srfi.schemers.org/srfi-17/srfi-17.html}

@noindent
for more details.  The following documentation is an unofficial Texinfo reformatting and minor
modification of the original document by Marco Maggi (Sun Oct 26, 2008).


@menu
* base setters srfi abstract::  Abstract.
* base setters srfi rationale:: Rationale.
* base setters srfi spec::      Specification.
* base setters srfi license::   License.
@end menu

@c page
@node base setters srfi abstract
@subsubsection Abstract


This is a proposal to allow procedure calls that evaluate to the ``value of a location'' to be used
to set the value of the location, when used as the first operand of @syntax{set!}.  For example:

@lisp
(set! (car x) (car y))
@end lisp

@noindent
becomes equivalent to

@lisp
(set-car! x (car y))
@end lisp

Many programming languages have the concept of an lvalue.  That is an ``expression'' that
``evaluates'' to a location, and which can appear on the left--hand--side of an assignment.  Common
Lisp has a related concept of ``generalised variables'' which can be used in @syntax{setf} and some
other special forms.  However, the Common Lisp concept is based on the idea of compile--time
recognition of special ``location--producing'' functions; this does not seem to be in the ``spirit of
Scheme''.

This @srfi{} proposes an extension of @syntax{set!} so that it provides similar functionality as
Common Lisp's setf, except that the updater is associated with a procedure value, rather than a
name.

@c page
@node base setters srfi rationale
@subsubsection Rationale


There is ample precedent for general ``lvalues'' on the left--hand side of an assignment.  This
includes most statically typed languages, and many dynamically typed languages (including APL and
Common Lisp).  That suggests this is a natural idiom for people.  One reason may be that there are
fewer procedure names to learn.  Another is that it becomes visually clearer which expression is the
new value, and which are parameters.  Also, the visual consistency between an expression evaluated
for its value and one evaluated to yield a location seems natural to people.

For most languages, the set of lvalue--producing operators is limited (typically array indexing and
field selection).  Some languages have general lvalues as first class values.  For example Algol 68
has expressions that have reference type.  However, this is made convenient by using automatic
dereferencing coercions, which would not work for a dynamically typed language like Scheme.  ML goes
further: All mutable variables are first--class ``cells'', and accessing the contents of a cell
requires an explicit operator.  This is also not compatible with Scheme.  Instead we need to stick
to the model where using a variable in most contexts means using its value, but refering to a
variable in certain lvalue contexts (lhs of assignment) refers to its actual location.  Sticking to
this model for general ``lvalue expressions'' in @syntax{set!} means that ``evaluation'' must be
done differently from normal evaluation when in an ``lvalue context''.  That is what this proposal
does.

This is a controversial issue.  This @srfi{} does not wish to imply that all Scheme implementations
should support this feature; it only requests that implementations that do implement generalised
@syntax{set!} should be compatible with this @srfi{}.

@c page
@node base setters srfi spec
@subsubsection Specification


The special form @syntax{set!} is extended so the first operand can be a procedure application, and
not just a variable.  The procedure is typically one that extracts a component from some data
structure.  Informally, when the procedure is called in the first operand of @syntax{set!}, it
causes the corresponding component to be replaced by the second operand.  For example,

@lisp
(set (vector-ref x i) v)
@end lisp

@noindent
would be equivalent to:

@lisp
(vector-set! x i v)
@end lisp

Each procedure that may be used as the first operand to @syntax{set!} must have a corresponding
``setter'' procedure.  The builtin procedure setter takes a procedure and returns the corresponding
setter procedure.

We define:

@lisp
(set! (proc arg ...) value)
@end lisp

@noindent
as:

@lisp
((setter proc) arg ... value)
@end lisp

Note: This definition matches the existing Scheme convention for setter procedures, where the new
value is given last.  For example we can define @code{(setter car)} to be @func{set-car!}.  An
alternative definition would be:

@lisp
((setter proc) value arg ...) ;; Not the actual definition.
@end lisp

This definition would work better when you consider procedures that take a variable number of
arguments.  This is because it is straight--forward to add one extra initial fixed argument, but if
you add an extra fixed argument to the end of an argument list that has a ``rest'' parameter, then
things get more messy.  However, consistency with the existing new--value--last convention seems
more valuable.

@c ------------------------------------------------------------------------

@subsubheading Standard setters


The following standard procedures have predefined setters:

@lisp
(set! (car x) v)           @equiv{} (set-car! x v)
(set! (cdr x) v)           @equiv{} (set-cdr! x v)
(set! (caar x) v)          @equiv{} (set-car! (car x) v)
(set! (cadr x) v)          @equiv{} (set-car! (cdr x) v)
....
(set! (caXXr x) v)         @equiv{} (set-car! (cXXr x) v)
(set! (cdXXr x) v)         @equiv{} (set-cdr! (cXXr x) v)
(set! (string-ref x i) v)  @equiv{} (string-set! x i v)
(set! (vector-ref x i) v)  @equiv{} (vector-set! x i v)
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Setting setters; properties

A setter procedure is a special case of the concept of procedures having associated properties.
Other properties might include the procedures's name or usage documentation.  As a hypothetical
example (i.e. not part of this @srfi{}), we can use the Common Lisp documentation function, where
for example:

@lisp
(documentation sqrt)
@end lisp

@noindent
returns the ``documentation string'' (if defined) for @func{sqrt}.  Such properties should also be
settable using generalized @syntax{set!}.  For example:

@lisp
(set! (documentation sqrt) "Calculates the square root.")
@end lisp

This @srfi{} does not propose a general ``procedure properties'' feature, but it should be
compatible with it.  It does specify the special case for the setter property.  This is defined such
that:

@lisp
(set! (setter @var{proc}) setter)
@end lisp

@noindent
sets the setter procedure associated with @var{proc} to setter.  For example, we can assume

@lisp
(set! (setter car) set-car!)
@end lisp

@noindent
has been executed by the Scheme prologue.

@c ------------------------------------------------------------------------

@subsubheading Efficiency Issues

If @code{(set! (foo ..) ...)} is to be the preferred idiom, we want to make @code{((setter foo)
...)} as efficient as @code{(set-foo! ...)}.  This is only possible when the compiler knows both
what function the symbol @code{foo} is bound to, and the setter associated with that function.

Scheme (as opposed to Common Lisp) does not say anything about a compiler or what it can inline, so
we cannot say much here.  A compiler that does whole--program analysis can safely inline calls using
a variable bound unchangeably to a known procedure; it can make the same deduction if the
procedure's setter is set.  If separate compilation is supported, then a compiler cannot safely make
such deductions for either plain calls or setter calls, without extra information, such as a module
system, compiler switches, or other non--standard declarations.  Thus my belief is that this @srfi{}
does not inherently make efficient compilation more difficult.  However, the next section does
define a way to inherently tie a setter to a procedure, which does reduce the problem of inlining
generalised @syntax{set!} to the standard inlining problem.

@c ------------------------------------------------------------------------

@subsubheading @func{getter-with-setter}


The function @func{getter-with-setter} can be used to define a procedure with associated properties.
Specifically:

@lisp
(getter-with-setter getter setter)
@end lisp

This evaluates to a new anonymous procedure which when applied invokes @code{getter}, and whose
setter is @code{setter}.  It is an error for a program to subsequently try to modify the setter of
the resulting compound.

For example, we could define:

@lisp
(define car (getter-with-setter %primitive-car %primitive-set-car!))
(define set-car! %primitive-set-car!)
@end lisp

The advantage of this approach that whenever a compiler can inline car, it can also inline
@code{(setter car)}.

@c page
@node base setters srfi license
@subsubsection License


Copyright @copyright{} Per Bothner (1999, 2000).  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the ``Software''), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

@c page
@node base setters ext
@subsection @chicken extensions


@defun setter @var{procedure}
Return the setter--procedure of @var{procedure}, or signals an error if @var{procedure} has no
associated setter--procedure.

Note that:

@lisp
(set! (setter @var{procedure}) ...)
@end lisp

@noindent
for a @var{procedure} that has no associated setter procedure yet is a very slow operation (the old
procedure is replaced by a modified copy, which involves a garbage collection).
@end defun


@defun getter-with-setter @var{getter} @var{setter}
Return a copy of the procedure @var{getter} with the associated setter procedure @var{setter}.
Contrary to the @srfi{} specification, the setter of the returned procedure may be changed.
@end defun

@c page
@node base optargs
@section Binding forms for optional arguments


@deffn Syntax optional @qvar{args} @qvar{default}
Use this form for procedures that take a single optional argument.  If @qvar{args} is the empty list
@qvar{default} is evaluated and returned, otherwise the first element of the list @qvar{args} is
returned.  It is an error if @qvar{args} contains more than one value.

@lisp
(define (incr x . i)
  (+ x (optional i 1)))

(incr 10)       @result{} 11
(incr 12 5)     @result{} 17
@end lisp
@end deffn


@deffn Syntax case-lambda (@qvar{formals} @qvaro{body} @qvar{body} @dots{}) @dots{}
Expand into a @syntax{lambda} that invokes the body following the first matching lambda--list.

@lisp
(define plus
  (case-lambda
    (() 0)
    ((x) x)
    ((x y) (+ x y))
    ((x y z) (+ (+ x y) z))
    (args (apply + args))))

(plus)          @result{} 0
(plus 1)        @result{} 1
(plus 1 2 3)    @result{} 6
@end lisp

For more information see the documentation for @ansrfi{16}
(http://srfi.schemers.org/srfi-16/srfi-16.html).

This special form is also compatible with the definition from the @rnrs{7} @library{scheme
case-lambda} library.
@end deffn


@deffn Syntax let-optionals @qvar{args} ((@qvari{var} @qvari{default}) @dots{}) @qvar{body} @dots{}
Binding constructs for optional procedure arguments.  @qvar{args} is normally a rest--parameter
taken from a lambda--list.  @syntax{let-optionals} binds the @qvar{var} elements to available
arguments in parallel, or to @qvar{default} if not enough arguments were provided.  It is an error
if any excess arguments are provided.

@lisp
(let-optionals '(one two)
    ((a 1)
     (b 2)
     (c 3))
  (list a b c))
@result{} (one two 3)
@end lisp
@end deffn


@deffn Syntax let-optionals* @qvar{args} ((@qvari{var} @qvari{default}) @dots{} @qvar{restvar}) @qvar{body} @dots{}
Binding constructs for optional procedure arguments.  @qvar{args} is normally a rest--parameter
taken from a lambda--list.  @syntax{let-optionals*} binds the @qvar{var} elements sequentially, so
every variable sees the previous ones.  If a single variable @qvar{restvar} is given, then it is
bound to any remaining arguments, otherwise it is an error if any excess arguments are provided.

@lisp
(let-optionals* '(one two)
    ((a 1)
     (b 2)
     (c a))
  (list a b c))
@result{} (one two one)
@end lisp
@end deffn

@c page
@node base binds
@section Other binding forms


@deffn Syntax and-let* (@qvar{binding} @dots{}) @qvaro{body} @qvar{body} @dots{})
Bind sequentially and execute a body.  @qvar{binding} can be one among:

@itemize
@item
A list of a variable and an expression.

@item
A list with a single expression

@item
A single variable.
@end itemize

If the value of an expression bound to a variable is @false{}, the @syntax{and-let*} form evaluates
to @false{} and the subsequent bindings and the body are not executed.  Otherwise the next binding
is performed.  If all bindings/expressions evaluate to a true result, the body is executed normally
and the result of the last expression is the result of the @syntax{and-let*} form.

See also the documentation for @ansrfi{2} (@url{http://srfi.schemers.org/srfi-2/srfi-2.html}).
@end deffn


@deffn Syntax letrec* ((@qvar{variable} @qvar{expression}) @dots{}) @qvaro{body} @qvar{body} @dots{}
Implements @rnrs{6}/@rnrs{7} @syntax{letrec*}: similar to @syntax{letrec} but binds the variables
sequentially and is to @syntax{letrec} what @syntax{let*} is to @syntax{let}.

This special form is compatible with the definition from the @rnrs{7} @library{scheme base} library.
@end deffn


@deffn Syntax rec @qvar{name} @qvar{expression}
@deffnx Syntax rec (@qvar{name} @qvar{variable} @dots{}) @qvaro{body} @qvar{body} @dots{}
Allow simple definition of recursive definitions:

@lisp
(rec @qvar{name} @qvar{expression})
@end lisp

@noindent
is equivalent to:

@lisp
(letrec ((@qvar{name} @qvar{expression}))
  @qvar{name})
@end lisp

@noindent
and:

@lisp
(rec (@qvar{name} @qvar{variable} @dots{}) @qvaro{body} @qvar{body} @dots{})
@end lisp

@noindent
is the same as:

@lisp
(letrec ((@qvar{name} (lambda (@qvar{variable} ...)
                  @qvaro{body} @qvar{body} @dots{})))
  @qvar{name})
@end lisp
@end deffn


@deffn Syntax cut @qvar{slot} @dots{}
@deffnx Syntax cute @qvar{slot} @dots{}
Syntactic sugar for specialising parameters (@url{http://srfi.schemers.org/srfi-26/srfi-26.html}).
@end deffn


@deffn Syntax define-values (@qvar{name} @dots{}) @qvar{valueexp}
@deffnx Syntax define-values (@qvari{name} ... @qvarn{name} . @qvar{name}) @qvar{valueexp}
@deffnx Syntax define-values @qvar{name} @qvar{valueexp}
Define several variables at once, with the result values of expression @qvar{valueexp}, similar to
@syntax{set!-values}.

This special form is compatible with the definition from the @rnrs{7} @library{scheme base} library.
@end deffn


@deffn Syntax fluid-let ((@qvari{var} @qvari{x}) @dots{}) @qvaro{body} @qvar{body} @dots{}
Bind the variables @qvar{var} dynamically to the values @qvar{x} during execution of the @qvar{body}
forms.  This implements @ansrfi{15} (@url{http://srfi.schemers.org/srfi-15/srfi-15.html}).
@end deffn


@deffn Syntax let-values ((@qvar{formals} @qvar{valueexp}) @dots{}) @qvaro{body} @qvar{body} @dots{}
Bind multiple variables to the result values of @qvar{valueexp}.  All variables are bound
simultaneously.  Like @syntax{define-values}, the @qvar{formals} expression can be any basic lambda
list (dotted tail notation is supported).

This special form implements @ansrfi{11} (@url{http://srfi.schemers.org/srfi-11/srfi-11.html}), and
it is also compatible with the definition from the @rnrs{7} @library{scheme base} library.
@end deffn


@deffn Syntax let*-values ((@qvar{formals} @qvar{valueexp}) @dots{}) @qvaro{body} @qvar{body} @dots{}
Bind multiple variables to the result values of @qvar{valueexp}.  The variables are bound
sequentially.  Like @syntax{let-values}, the @qvar{formals} form can be any basic lambda list
(dotted tail notation is supported).

This is also part of @ansrfi{11} (@url{http://srfi.schemers.org/srfi-11/srfi-11.html}) and is also
compatible with the definition from the @rnrs{7} @library{scheme base} library.

@lisp
(let*-values (((a b) (values 2 3))
              ((p)   (+ a b)))
  p)
@result{} 5
@end lisp
@end deffn


@deffn Syntax letrec-values ((@qvar{formals} @qvar{valueexp}) @dots{}) @qvaro{body} @qvar{body} @dots{}
Bind the result values of @qvar{valueexp} to multiple variables at once.  All variables are mutually
recursive.  Like @syntax{let-values}, the @qvar{formals} form can be any basic lambda list (dotted
tail notation is supported).

@lisp
(letrec-values (((odd even)
                   (values
                     (lambda (n) (if (zero? n) #f (even (sub1 n))))
                     (lambda (n) (if (zero? n) #t (odd  (sub1 n)))))))
  (odd 17))
@result{} #t
@end lisp
@end deffn


@deffn Syntax receive @qvar{formals} @qvar{valueexp} @qvaro{body} @qvar{body} @dots{}
@deffnx Syntax receive @qvar{valueexp}
Syntactic sugar for @syntax{call-with-values}.  The @qvar{formals} form can be any basic lambda list
(dotted tail notation is supported).  Binds variables to the result values of @qvar{valueexp} and
evaluates the @qvar{body} forms, similar @syntax{define-values} but lexically scoped.  This is the
implementation of @ansrfi{8} (@url{http://srfi.schemers.org/srfi-8/srfi-8.html}).

@code{(receive @qvar{valueexp})} is equivalent to @code{(receive _ @qvar{valueexp} _)}; this
shortened form is not described by @ansrfi{8}.
@end deffn


@deffn Syntax set!-values @qvar{formals} @qvar{valueexp}
The @qvar{formals} form can be any basic lambda list (dotted tail notation is supported).  Assign
the result values of expression @qvar{valueexp} to multiple variables, similar to
@syntax{define-values}.
@end deffn


@deffn Syntax nth-value @qvar{N} @qvar{exp}
Returns the @var{N}th value (counting from zero) of the values returned by expression @var{EXP}.
@end deffn

@c page
@node base parms
@section Parameters


Parameters are @chicken{}'s form of dynamic variables, except that they are procedures rather than
actual variables.  A parameter is a procedure of zero or one arguments.  To retrieve the value of a
parameter call the parameter--procedure with zero arguments.  To change the setting of the
parameter, call the parameter-procedure with the new value as argument:

@lisp
(define foo (make-parameter 123))
(foo)           @result{} 123
(foo 99)
(foo)           @result{} 99
@end lisp

Parameters are fully thread--local, each thread of execution owns a local copy of a parameters'
value.

@chicken{} implements @ansrfi{39} (http://srfi.schemers.org/srfi-39/srfi-39.html), which is also
standardized by @rnrs{7}.


@deffn Syntax parameterize ((@qvar{parameter} @qvar{expr}) @dots{}) @qvaro{body} @qvar{body} @dots{})
Bind the parameters @qvar{parameter} dynamically to the values @qvar{expr} during execution of the
@qvar{body} forms.  Note that @qvar{parameter} may be any expression that evaluates to a parameter
procedure.

This special form is compatible with the definition from the @rnrs{7} @library{scheme base} library.
@end deffn


@defun make-parameter @var{value}
@defunx make-parameter @var{value} @var{guard}
Return a procedure that accepts zero or one argument.  Invoking the procedure with zero arguments
returns @qvar{value}.  Invoking the procedure with one argument changes its value to the value of
that argument and returns the new value (subsequent invocations with zero parameters return the new
value).  @var{guard} should be a procedure of a single argument: any new values of the parameter
(even the initial value) are passed to this procedure; the guard procedure should check the value
and/or convert it to an appropriate form.

This special form is compatible with the definition from the @rnrs{7} @library{scheme base} library.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Built--in parameters

Certain behavior of the interpreter and compiled programs can be customized via the following
built--in parameters


@deffn Parameter case-sensitive
If true, then @func{read} reads symbols and identifiers in case--sensitive mode and uppercase
characters in symbols are printed escaped.  Defaults to @true{}.
@end deffn


@deffn Parameter keyword-style
Enable alternative keyword syntax, where the value of the parameter may be either @keyword{prefix}
(as in Common Lisp), which recognises symbols beginning with a colon as keywords, or
@keyword{suffix} (as in @acronym{dsssl}), which recognises symbols ending with a colon as keywords.
Any other value disables the alternative syntaxes.  In the interpreter the default is
@keyword{suffix}.
@end deffn


@deffn Parameter parenthesis-synonyms
If true, then the list delimiter synonyms @samp{#\[} @samp{#\]} and @samp{#\@{} @samp{#\@}} are
enabled.  Defaults to @true{}.
@end deffn


@deffn Parameter symbol-escape
If true, then the symbol escape @samp{#\|} @samp{#\|} is enabled.  Defaults to @true{}.
@end deffn

@c page
@node base inline
@section Substitution forms and macros


@deffn Syntax define-constant @qvar{name} @qvar{const}
Define a variable with a constant value, evaluated at compile--time.  Any reference to such a
constant should appear textually @strong{after} its definition.  This construct is equivalent to
@syntax{define} when evaluated or interpreted.  @qvar{const} may be any constant expression, and may
also refer to constants defined via @syntax{define-constant} previously, but it must be possible to
evaluate the expression at compile--time.

Constant definitions should only appear at toplevel.  Note that constants are local to the current
compilation unit and are not available outside of the source file in which they are defined.  Names
of constants still exist in the Scheme namespace and can be lexically shadowed.  If the value is
mutable, then the compiler is careful to preserve its identity.
@end deffn


@deffn Syntax define-inline (@qvar{name} . @qvar{formals}) @qvaro{body} @qvar{body} @dots{}
@deffnx Syntax define-inline @qvar{name} @qvar{exp}
Define an inline procedure.  Any occurrence of @qvar{name} will be replaced by @var{EXP} or:

@lisp
(lambda @var{formals}
  @qvaro{body} @qvar{body} @dots{})
@end lisp

In the third form, @var{EXP} must be a lambda expression.  This is similar to a macro, but variable
names and scope are handled correctly.

Inline substitutions take place @strong{after} macro--expansion, and any reference to @qvar{name}
should appear textually @strong{after} its definition.  Inline procedures are local to the current
compilation unit and are not available outside of the source file in which they are defined.  Names
of inline procedures still exist in the Scheme namespace and can be lexically shadowed.  Inline
definitions should only appear at the toplevel.

Note that the @code{inline-limit} compiler option does not affect inline procedure expansion, and
self--referential inline procedures may cause the compiler to enter an infinite loop.

This construct is equivalent to @syntax{define} when evaluated or interpreted.
@end deffn

@c page
@node base cond
@section Conditional forms


@deffn Syntax select @qvar{exp} ((@qvar{key} @dots{}) @qvaro{kexp} @qvar{kexp} @dots{}) @dots{}
@deffnx Syntax select @qvar{exp} ((@qvar{key} @dots{}) @qvaro{kexp} @qvar{kexp} @dots{}) @dots{} (else @qvaro{exp} @qvar{exp} @dots{})
This is similar to @syntax{case}, but the keys are evaluated.
@end deffn


@deffn Syntax when @qvar{test} @qvaro{exp} @qvar{exp} @dots{}
Equivalent to:

@lisp
(if @qvar{test} (begin @qvaro{exp} @qvar{exp} @dots{})
@end lisp
@end deffn


@deffn Syntax unless @qvar{test} @qvaro{exp} @qvar{exp} @dots{}
Equivalent to:

@lisp
(if (not @qvar{test}) (begin @qvaro{exp} @qvar{exp} @dots{})
@end lisp
@end deffn

@c page
@node base records
@section Record structures


@cindex Records, definition
@cindex Defining record types


@deffn Syntax define-record @qvar{name} @qvar{slotspec} @dots{}
Define a record type.  This defines a number of procedures for creating, accessing, and modifying
record members.  The form @qvar{name} must be a symbol representing the record--type name; the
@qvar{slotspec} forms can be symbols representing the slot names.

If we use this macro with @samp{foo} as @qvar{name} and @samp{bar} as slotspec, the following
functions will be defines:

@table @samp
@item make-foo
The record constructor, it has one initialisation argument for each slot, in the listed order.

@item foo?
The record predicate.

@item foo-bar
@itemx foo-bar-set!
Slot accessor and mutator.
@end table

Usage example:

@lisp
(define-record point x y)
(define p1 (make-point 123 456))
(point? p1)             @result{} #t
(point-x p1)            @result{} 123
(point-y-set! p1 99)
(point-y p1)            @result{} 99
@end lisp

@chicken{} supports @ansrfi{17} setters.  So @qvar{slotspec} may alternatively also be of the form:

@lisp
(setter @qvar{slotname})
@end lisp

@noindent
in this case @qvar{slotname} will become the name of a setter--with--getter we can use to access and
mutate the slot.  Usage examples:

@lisp
(define-record point (setter x) (setter y))
(define p1 (make-point 123 456))
(point? p1)             @result{} #t
(point-x p1)            @result{} 123
(set! (point-y p1) 99)
(point-y p1)            @result{} 99
@end lisp
@end deffn


@deffn Syntax define-record-type @qvar{name} (@qvar{constructor} @qvar{tag} @dots{}) @qvar{predicate} @qvar{slotspec} @dots{}
Define @ansrfi{9} record types.  For more information see the documentation for @ansrfi{9}
(@url{http://srfi.schemers.org/srfi-9/srfi-9.html}).

The form @qvar{name} must be a symbol representing the record--type name.  The form
@qvar{constructor} must be a symbol representing the constructor name.  The form @qvar{predicate}
must be a symbol representing the record--type predicate name.

The @qvar{tag} forms must be symbols and they become the arguments of the constructor; they must
match the field names as specified in @qvar{fieldspec}.  The can be a constructor argument for each
field, but some fields might be left uninitialised, in which case they are set to the unspecified
value (the return value of @code{(void)}).

Each @qvar{slotspec} form must have one of the formats:

@lisp
(@qvar{field} @qvar{accessor})
(@qvar{field} @qvar{accessor} @qvar{modifier})
(@qvar{field} @qvar{accessor} (setter @qvar{modifier}))
@end lisp

@noindent
where:

@table @asis
@item @qvar{field}
Must be a symbol representing the field name.

@item @qvar{accessor}
must be a symbol representing the field accessor name.

@item @qvar{modifier}
Can be either a symbol representing the field mutator name, or, with the @syntax{setter} form, will
define a @ansrfi{17} setter--procedure for the given @qvar{accessor} procedure that sets the field
value; usually @qvar{modifier} has the same name is @qvar{accessor} (but it doesn't have to).

If @qvar{modifier} is not present in a field specification: the corresponding field is immutable.
@end table

This special form is also compatible with the definition from the @rnrs{7} @library{scheme base}
library.

Let's see an example with field accessors and field mutators:

@lisp
(define-record-type <colour>
  (make-colour red green blue)
  colour?
  (red   colour-red)
  (green colour-green colour-green-set!)
  (blue  colour-blue  colour-blue-set!))

(define O
  (make-colour 1 2 3))

(colour-green-set! O 99)

(colour?      O)        @result{} #t
(colour-red   O)        @result{} 1
(colour-green O)        @result{} 99
(colour-blue  O)        @result{} 3
@end lisp

@noindent
let's see an example with a field left uninitialised by the constructor:

@lisp
(define-record-type <colour>
  (make-colour red blue)
  colour?
  (red   colour-red)
  (green colour-green)
  (blue  colour-blue))

(define O
  (make-colour 1 3))

(colour?      O)        @result{} #t
(colour-red   O)        @result{} 1
(colour-green O)        @result{} #<unspecified>
(colour-blue  O)        @result{} 3
@end lisp

@noindent
let's see an example with field accessors, field mutators and a field setter:

@lisp
(define-record-type <colour>
  (make-colour red green blue)
  colour?
  (red   colour-red)
  (green colour-green (setter colour-green))
  (blue  colour-blue  colour-blue-set!))

(define O
  (make-colour 1 2 3))

(set! (colour-green O) 99)

(colour?      O)        @result{} #t
(colour-red   O)        @result{} 1
(colour-green O)        @result{} 99
(colour-blue  O)        @result{} 3
@end lisp
@noindent

@noindent
let's see an example with field accessors, field mutators and a field setter whose name is different
from the corresponding field accessor; notice that a procedure with such name must already exists:

@lisp
(define (blue O)
  #f)

(define-record-type <colour>
  (make-colour red green blue)
  colour?
  (red   colour-red)
  (green colour-green (setter colour-green))
  (blue  colour-blue  (setter blue)))

(define O
  (make-colour 1 2 3))

(set! (colour-green O) 88)
(set! (blue O) 99)

(colour?      O)        @result{} #t
(colour-red   O)        @result{} 1
(colour-green O)        @result{} 88
(colour-blue  O)        @result{} 99
@end lisp
@end deffn


@deffn Syntax define-record-printer (@qvar{name} @qvar{recordvar} @qvar{portvar}) @qvar{exp} @dots{}
@deffnx Syntax define-record-printer @qvar{name} @qvar{procedure}
Define a printing method for record of the type @qvar{name} by associating a procedure with the
record type.  When a record of this type is written using @func{display}, @func{write} or
@func{print}, then the procedure is called with two arguments: the record to be printed and an
output--port.

@lisp
(define-record-type foo (make-foo x y z) foo?
  (x foo-x)
  (y foo-y)
  (z foo-z))

(define f (make-foo 1 2 3))

(define-record-printer (foo x out)
  (fprintf out "#,(foo ~S ~S ~S)"
    (foo-x x) (foo-y x) (foo-z x)))

(define-reader-ctor 'foo make-foo)

(define s (with-output-to-string
            (lambda ()
              (write f))))

s
@result{} "#,(foo 1 2 3)"

(equal? f (with-input-from-string s read))
@result{} #t
@end lisp
@end deffn

@c page
@node base forms
@section Other forms


@deffn Syntax include @qvar{string}
Include toplevel--expressions from the given source file in the currently compiled/interpreted
program.  If the included file has the extension @samp{.scm}, then the extension itself may be
omitted.  The file is searched for in the current directory and all directories specified by the
@option{-include-path} option.
@end deffn


@deffn Syntax include-relative @qvar{string}
Like @syntax{include}, but the filename is searched for relative to the including file rather than
the current directory.
@end deffn

@c page
@node base libs
@section Making extra libraries and extensions available


@deffn Syntax require-library @qvar{id} @dots{}
This form does all the necessary steps to make the libraries or extensions given in @qvar{id}
available.  It loads syntactic extensions, if needed and generates code for loading/linking with
core library modules or separately installed extensions.

During @strong{interpretation} or @strong{evaluation} @syntax{require-library} performs one of the
following:

@itemize
@item
If @qvar{id} names a built--in feature:

@example
chicken
srfi-0          srfi-2          srfi-6
srfi-8          srfi-9          srfi-10
srfi-17         srfi-23         srfi-30
srfi-39         srfi-55
@end example

@noindent
then nothing is done.

@item
If @qvar{id} names one of the syntactic extensions:

@example
chicken-syntax
chicken-ffi-syntax
@end example

@noindent
then this extension will be loaded.

@item
If @qvar{id} names one of the core library units shipped with @chicken{}, then a:

@lisp
(load-library (quote @qvar{id}))
@end lisp

@noindent
will be performed.

@item
If @qvar{id} names an installed extension with the @syntax{syntax} or @syntax{require-at-runtime}
attribute, then the extensions is loaded at compile--time, probably doing a run--time @code{(require
...)} for any run--time requirements.

@item
Otherwise, @code{(require-library @qvar{id})} is equivalent to @code{(require (quote @qvar{id}))}.
@end itemize

During @strong{compilation}, one of the following happens instead:

@itemize
@item
If @qvar{id} names a built-in feature:

@example
chicken
srfi-0          srfi-2          srfi-6
srfi-8          srfi-9          srfi-10
srfi-17         srfi-23         srfi-30
srfi-39         srfi-55
@end example

@noindent
then nothing is done.

@item
If @qvar{id} names one of the syntactic extensions:

@example
chicken-syntax
chicken-ffi-syntax
@end example

@noindent
then this extension will be loaded at compile--time, making the syntactic extensions available in
compiled code.

@item
If @qvar{id} names one of the core library units shipped with @chicken{}, or if the option
@code{-uses @qvar{id}} has been passed to the compiler, then a:

@lisp
(declare (uses @qvar{id}))
@end lisp

@noindent
is generated.

@item
If @qvar{id} names an installed extension with the @syntax{syntax} or @syntax{require-at-runtime}
attribute, then the extension is loaded at compile--time, and code is emitted to @code{(require
...)} any needed run--time requirements.

@item
Otherwise @code{(require-library @qvar{id})} is equivalent to @code{(require (quote @qvar{ID}))}.
@end itemize

@qvar{id} should be a pure extension name and should not contain any path prefixes (for example
@samp{dir/lib...} is illegal).

@qvar{id} may also be a list that designates an extension--specifier.  Currently the following
extension specifiers are defined:

@table @code
@item srfi @qvar{number} ...
Is required for @ansrfi{55} compatibility and is fully implemented.

@item (version @qvar{id} @qvar{number})
Is equivalent to @qvar{id}, but checks at compile--time whether the extension named @qvar{id} is
installed and whether its version is equal or higher than @qvar{number}.  @qvar{number} may be a
string or a number, the comparison is done lexicographically (using @func{string>=?}).
@end table
@end deffn


@deffn Syntax require-extension @qvar{id} @dots{}
This is equivalent to:

@lisp
(require-library @qvar{id} ...)
@end lisp

@noindent
but performs an implicit @syntax{import}, if necessary.  Since @chicken{} version 4.4.0, @qvar{id}
may also be an import specification (using @syntax{rename}, @syntax{only}, @syntax{except} or
@syntax{prefix}).

In short: we should just use @syntax{require-extension} and it will normally figure everything out
for dynamically loadable extensions and core library units.

This implementation of @syntax{require-extension} is compliant with @ansrfi{55}
(@url{http://srfi.schemers.org/srfi-55/srfi-55.html}).
@end deffn

@c page
@node base process
@section Process shutdown


@defun emergency-exit
@defunx emergency-exit @var{code}
Exit the current process without flushing any buffered output (using the C function @cfunc{_exit}).
Note that the @func{exit-handler} is not called when this procedure is invoked.  The optional exit
status code @var{code} defaults to @samp{0}.
@end defun


@defun exit
@defunx exit @var{code}
Exit the running process and return @var{code}, which defaults to @samp{0}; this function invokes
@func{exit-handler}.

Note that pending @func{dynamic-wind} thunks are @strong{not} invoked when exiting your program in
this way.
@end defun


@deffn Parameter exit-handler
A procedure of a single optional argument.  When @func{exit} is called, then this procedure will be
invoked with the exit--code as argument.  The default behavior is to terminate the program.

Note that this handler is @strong{not} invoked when @func{`emergency-exit} is used.
@end deffn


@deffn Parameter implicit-exit-handler
A procedure of no arguments.  When the last toplevel expression of the program has executed, then
the value of this parameter is called.  The default behaviour is to invoke all pending finalisers.
@end deffn


@defun on-exit @var{thunk}
Schedules the zero--argument procedure @var{thunk} to be executed before the process exits, either
explicitly via @func{exit} or implicitly after execution of the last top--level form.  Note that
finalisers for unreferenced finalised data are run before exit procedures.
@end defun

@c page
@node base system
@section System interface


@defun sleep @var{seconds}
Put the program to sleep for @var{seconds}.  If the scheduler is loaded (for example when
@ansrfi{18} is in use) then only the calling thread is put to sleep and other threads may continue
executing.  Otherwise, the whole process is put to sleep.
@end defun

@c page
@node base ports
@section Ports


@defun open-output-string
@defunx get-output-string @var{port}
@func{open-output-string} returns a ``string output port'' for accumulating output in a string.
@func{get-output-string} returns the output accumulated in a string port created with
@code{(open-output-string)}.

@lisp
(let ((port (open-output-string)))
  (display "ciao" port)
  (display " mamma" port)
  (get-output-string port))
@result{} "ciao mamma"
@end lisp
@end defun


@defun open-input-string @var{string}
Return a port for reading from @var{string}.

@lisp
(let ((port (open-input-string "ciao mamma")))
  (let* ((A (read port))
         (B (read port)))
    (list A B)))
@result{} (ciao mamma)
@end lisp
@end defun


@defun flush-output
@defunx flush-output @var{output-port}
Write buffered output to the given @var{output-port}.  @var{output-port} defaults to the value of
@code{(current-output-port)}.
@end defun


@defun input-port-open? @var{port}
Return @true{} if the given @var{PORT} is open for input; otherwise return @false{}.
@end defun


@defun output-port-open? @var{port}
Return @true{} if the given @var{PORT} is open for output; otherwise return @false{}.
@end defun


@defun port-closed? @var{port}
Return @true{} if the given @var{PORT} closed in all directions; otherwise return @false{}.
@end defun


@defun port? @var{X}
Return @true{} if @var{X} is a port object; return @false{} otherwise.
@end defun

@c page
@node blob
@chapter Module @library{chicken blob}


@cindex @library{chicken blob} module
@cindex Module @library{chicken blob}


@c page
@node condition
@chapter Module @library{chicken condition}


@cindex @library{chicken condition} module
@cindex Module @library{chicken condition}


This module provides various procedures and special forms for raising and handling exceptions with
``condition objects''.  Condition objects provide a structured and composable way to encode the kind
of exception that took place, and provide the necessary context.

@chicken{}'s exception handling is based on the
@url{@url{http://srfi.schemers.org/srfi-12/srfi-12.html}, @ansrfi{12}} exception system.  This
chapter contains the core of the @ansrfi{12} spec as well as @chicken{} implementation specifics.

There is also a @code{srfi-12} or @library{srfi 12} module which only includes the standard
procedures and macros from the @srfi{} document, without the @chicken{} extensions.
@library{chicken condition} offers the complete set of procedures and macros, both
@chicken{}--specific and standard @ansrfi{12}.

@menu
* condition srfi-12::           @ansrfi{12} specification.
* condition chicken::           @chicken{} implementation.
@end menu

@c page
@node condition srfi-12
@section @ansrfi{12} specification


A Scheme implementation (``the system'') raises an exception whenever an error is to be signalled or
whenever the system determines that evaluation cannot proceed in a manner consistent with the
semantics of Scheme.  A program may also explicitly raise an exception.

Whenever the system raises an exception, it invokes the current exception handler with a condition
object (encapsulating information about the exception) as its only argument.  Any procedure
accepting one argument may serve as an exception handler.  When a program explicitly raises an
exception, it may supply any object to the exception handler.

An exception is either continuable or non--continuable.  When the current exception handler is
invoked for a continuable exception, the continuation uses the handler's result(s) in an
exception--specific way to continue.  When an exception handler is invoked for a non--continuable
exception, the continuation raises a non--continuable exception indicating that the exception
handler returned.  On @chicken{}, system error exceptions (of kind @code{exn}) are non--continuable.

@menu
* condition srfi-12 handlers::  Exception handlers.
* condition srfi-12 raising::   Raising exceptions.
* condition srfi-12 condition:: Condition objects.
* condition srfi-12 examples::  More examples.
@end menu

@c page
@node condition srfi-12 handlers
@subsection Exception handlers


@deffn Parameter current-exception-handler
@deffnx Parameter current-exception-handler @var{procedure}
Set or return the current exception handler, a procedure of one argument, the exception object.
@end deffn


@defun with-exception-handler @var{handler} @var{thunk}
Install the procedure @var{handler} as current exception handler in the dynamic environment, then
invoke @var{thunk}.  When @var{thunk} returns successfully: return the values returned by
@var{thunk}.

@strong{NOTE} When using @chicken{}'s default exception handler: the @var{handler} must @strong{not}
return locally: instead it must escape to a different continuation.  A normal return will cause an
exception to be raised in the same dynamic environment, with the same handler, so entering an
infinite loop.

Usage examples:

@lisp
(call-with-current-continuation
    (lambda (escape)
      (with-exception-handler
          (lambda (E)
            (escape 456))
        (lambda ()
          123))))
@result{} 123

(call-with-current-continuation
    (lambda (escape)
      (with-exception-handler
          (lambda (E)
            (escape (list (condition-who E)
                          (condition-message E)
                          (condition-irritants E))))
        (lambda ()
          (signal
            (make-property-condition 'demo
                                     'location 'me
                                     'message "the message"
                                     'irritants '(1 2 3)))))))
@result{} (me "the message" (1 2 3))
@end lisp
@end defun


@deffn Syntax handle-exceptions @qvar{var} @qvar{handle-expr} @qvaro{expr} @qvar{expr} @dots{}
Evaluate the body expressions @qvar{expr} in sequence with an exception handler constructed from
@qvar{var} and @qvar{handle-expr}.  Assuming no exception is raised, the result(s) of the last body
expression is(are) the result(s) of the @syntax{handle-exceptions} expression.

The exception handler created by @syntax{handle-exceptions} restores the dynamic context
(continuation, exception handler, etc.) of the @syntax{handle-exceptions} expression, and then
evaluates @qvar{handle-expr} with @qvar{var} bound to the value provided to the handler.

Examples:

@lisp
(handle-exceptions exn
    (begin
      (display "Went wrong")
      (newline))
  (car '()))
@print{} "Went wrong"

(handle-exceptions exn
    (cond ((eq? exn 'one)
           1)
          (else
           (abort exn)))
  (case (random 3)
    ((0)        'zero)
    ((1)        (abort 'one))
    (else       (abort "Something else"))))
@end lisp
@end deffn

@c page
@node condition srfi-12 raising
@subsection Raising exceptions


@defun abort @var{obj}
Raises a non--continuable exception represented by @var{obj}.  The @func{abort} procedure can be
implemented as follows:

@lisp
(define (abort obj)
  ((current-exception-handler) obj)
  (abort
    (make-property-condition 'exn
      'message "Exception handler returned")))
@end lisp

The `abort` procedure does not ensure that its argument is a condition.  If its argument is a
condition: `abort` does not ensure that the condition indicates a non-continuable exception.
@end defun


@defun signal @var{obj}
Raise a continuable exception represented by @var{obj}.  The @func{signal} procedure can be
implemented as follows:

@lisp
(define (signal exn)
  ((current-exception-handler) exn))
@end lisp

The @func{signal} procedure does not ensure that its argument is a condition.  If its argument is a
condition: @func{signal} does not ensure that the condition indicates a continuable exception.
@end defun

@c page
@node condition srfi-12 condition
@subsection Condition objects


@defun condition? @var{obj}
Return @true{} if @var{obj} is a condition, otherwise returns @false{}.  If any of the predicates
listed in Section 3.2 of the @rnrs{5} is true of @var{obj}, then @func{condition?} is false of
@var{obj}.

Rationale: Any Scheme object may be passed to an exception handler.  This would cause ambiguity if
conditions were not disjoint from all of Scheme's standard types.
@end defun


@defun make-property-condition @var{kind-key} @var{prop-key} @var{value} @dots{}
This procedure accepts any even number of arguments after @var{kind-key}, which are regarded as a
sequence of alternating @var{prop-key} and @var{value} objects.  Each @var{prop-key} is regarded as
the name of a property, and each @var{value} is regarded as the value associated with the @var{key}
that precedes it.  Return a @var{kind-key} condition that associates the given @var{prop-key}s with
the given @var{value}s.
@end defun


@defun make-composite-condition @var{condition} @dots{}
Return a newly--allocated condition whose components correspond to the given @var{condition}s.  A
predicate created by @func{condition-predicate} returns true for the new condition if and only if it
returns true for one or more of its component conditions.
@end defun


@defun condition-predicate @var{kind-key}
Return a predicate that can be called with any object as its argument.  Given a condition that was
created by @func{make-property-condition}, the predicate returns @true{} if and only if
@var{kind-key} is @func{eqv?} to the kind key that was passed to @func{make-property-condition}.
Given a composite condition created with @func{make-composite-condition}, the predicate returns
@true{} if and only if the predicate returns @true{} for at least one of its components.
@end defun


@defun condition-property-accessor @var{kind-key} @var{prop-key}
@defunx condition-property-accessor @var{kind-key} @var{prop-key} @var{default}
Return a procedure that can be called with any condition that satisfies:

@lisp
(condition-predicate @var{kind-key})
@end lisp

Given a condition that was created by @func{make-property-condition} and @var{kind-key}, the
procedure returns the value that is associated with @var{prop-key}.  Given a composite condition
created with @func{make-composite-condition}, the procedure returns the value that is associated
with @var{prop-key} in one of the components that satisfies:

@lisp
(condition-predicate @var{kind-key})
@end lisp

On @chicken{}, this procedure accepts an optional third argument @var{default}.  If the condition
does not have a value for the desired property and if the optional argument is given, no error is
signalled and the accessor returns the third argument.

When the system raises an exception, the condition it passes to the exception handler includes the
@code{exn} kind with the following properties:

@table @code
@item message
@cindex Condition property @code{message}
@cindex @code{message}, condition property
The error message.

@item arguments
@cindex Condition property @code{arguments}
@cindex @code{arguments}, condition property
The arguments passed to the exception handler.

@item location
@cindex Condition property @code{location}
@cindex @code{location}, condition property
The name of the procedure where the error occurred (if available).
@end table

Thus, if @var{exn} is a condition representing a system exception, then:

@lisp
((condition-property-accessor 'exn 'message) exn)
@end lisp

@noindent
extracts the error message from @var{exn}.  Example:

@lisp
(handle-exceptions exn
    (begin
      (display "Went wrong: ")
      (display ((condition-property-accessor 'exn 'message) exn))
      (newline))
  (car '()))
; displays something like "Went wrong: can't take car of nil"
@end lisp
@end defun

@c page
@node condition srfi-12 examples
@subsection More examples


@lisp
  (define (try-car v)
   (let ((orig (current-exception-handler)))
     (with-exception-handler
      (lambda (exn)
        (orig (make-composite-condition
             (make-property-condition
              'not-a-pair
              'value
              v)
             exn)))
      (lambda () (car v)))))

  (try-car '(1))
  ;=> 1

  (handle-exceptions exn
                   (if ((condition-predicate 'not-a-pair) exn)
                       (begin
                        (display "Not a pair: ")
                        (display
                         ((condition-property-accessor 'not-a-pair 'value) exn))
                        (newline))
                       (abort exn))
    (try-car 0))
  ; displays "Not a pair: 0"

  (let* ((cs-key (list 'color-scheme))
         (bg-key (list 'background))
         (color-scheme? (condition-predicate cs-key))
         (color-scheme-background
        (condition-property-accessor cs-key bg-key))
         (condition1 (make-property-condition cs-key bg-key 'green))
         (condition2 (make-property-condition cs-key bg-key 'blue))
         (condition3 (make-composite-condition condition1 condition2)))
    (and (color-scheme? condition1)
         (color-scheme? condition2)
         (color-scheme? condition3)
         (color-scheme-background condition3)))
  ; => 'green or 'blue
@end lisp

@c page
@node condition chicken
@section @chicken{} implementation


@menu
* condition chicken system::    System conditions.
* condition chicken notes::     Notes.
* condition chicken api::       Additional @api{}.
@end menu

@c page
@node condition chicken system
@subsection System conditions


All error--conditions signaled by the system are of kind @code{exn}.  The following composite
conditions are additionally defined:

@table @code
@item (exn arity)
Signalled when a procedure is called with the wrong number of arguments.

@item (exn type)
Signalled on type--mismatch errors, for example when an argument of the wrong type is passed to a
built--in procedure.

@item (exn arithmetic)
Signalled on arithmetic errors, like division by zero.

@item (exn i/o)
Signalled on input/output errors.

@item (exn i/o file)
Signalled on file--related errors.

@item (exn i/o net)
Signalled on network errors.

@item (exn bounds)
Signalled on errors caused by accessing non--existent elements of a collection.

@item (exn runtime)
Signalled on low--level runtime--system error--situations.

@item (exn runtime limit)
Signalled when an internal limit is exceeded (like running out of memory).

@item (exn match)
Signalled on errors raised by failed matches (see the section on @func{match}).

@item (exn syntax)
Signalled on syntax errors.
@end table

@c page
@node condition chicken notes
@subsection Notes


@itemize
@item
All error--exceptions (of the kind @code{exn}) are non--continuable.

@item
Error--exceptions of the @code{exn} kind have additional @code{arguments} and @code{location}
properties that contain the arguments passed to the exception--handler and the name of the procedure
where the error occurred (if available).

@item
Within the interpreter (@command{csi}), a user--interrupt (@code{signal/int}) signals an exception
of the kind @code{user-interrupt}.

@item
The procedure @func{condition-property-accessor} accepts an optional third argument.  If the
condition does not have a value for the desired property and if the optional argument is given, no
error is signalled and the accessor returns the third argument.

@item
On platforms that support the @cfunc{sigprocmask} @posix{} @api{} function, the signals
@code{SIGSEGV}, @code{SIGFPE}, @code{SIGBUS} and @code{SIGILL} will be caught and trigger an
exception instead of aborting the process, if possible.  If the unwinding and handling of the signal
raises one of these signals once again, the process will abort with an error message.
@end itemize

@c page
@node condition chicken api
@subsection Additional @api{}


@deffn Syntax condition-case @qvar{expr} @qvar{clause} @dots{}
Build an exception handler using the given clauses and install it; then evaluate the expression
@qvar{expr} in the resulting dynamic environment.

@itemize
@item
When @qvar{expr} returns locally: return the values returned by @qvar{expr}.

@item
When @qvar{expr} raises an exception: the installed exception handler is invoked: its argument is
the raised object; it will select the clause with matching condition kind and evaluate its body
forms; the return value of @syntax{condition-case} is the return value of the body forms.
@end itemize

Each @qvar{clause} must have one of the formats:

@example
(@qvar{kindlist} @qvaro{body} @qvar{body} @dots{})
(@qvar{var} @qvar{kindlist} @qvaro{body} @qvar{body} @dots{})
@end example

@noindent
and the element @qvar{kindlist} must have the format:

@example
(@qvaro{kind} @qvar{kind} @dots{})
@end example

@noindent
only the system exceptions are allowed to use a list of symbols as condition kind, so for all the
custom exceptional conditions the available formats are just:

@example
()
(@qvar{kind})
@end example

@noindent
an empty list of condition kinds will match any condition kind; we can use this rule to implement an
``else'' clause.

When present: @qvar{var} is a local variable bound to the raised object; we can use it in the
@qvar{body} forms.

Some usage examples:

@lisp
(condition-case
    (raise (make-error))
  (()   'here))
@result{} here

(condition-case
    (raise (make-error))
  ((&warning)   'warning)
  ((&error)     'error)
  (()           'else))
@result{} error

(condition-case
    (raise (make-who-condition 'me))
  ((&warning)   'warning)
  ((&error)     'error)
  (()           'else))
@result{} else

(condition-case
    (raise (make-error))
  (var ()
    (list 'here (condition-kinds var))))
@result{}(here (&error &serious &condition))

(condition-case
    (raise (make-error))
  ((&warning)
   'warning)
  (var (&error)
    (list 'error (condition-kinds var)))
  (()
   'else))
@result{} (error (&error &serious &condition))

(condition-case
    (raise (make-warning))
  ((&syntax)
   'syntax)
  ((&error)
   'error)
  (var ()
    (list 'else (condition-kinds var))))
@result{} (else (&warning &condition))
@end lisp
@end deffn


@defun get-condition-property @var{condition} @var{kind} @var{property}
@defunx get-condition-property @var{condition} @var{kind} @var{property} @var{DEFAULT}
A slightly more convenient condition property accessor, equivalent to:

@lisp
((condition-property-accessor @var{kind} @var{property}) @var{condition})
((condition-property-accessor @var{kind} @var{property} [@var{default}]) @var{condition})
@end lisp
@end defun


@defun condition @varo{lst} @var{LST} @dots{}
This is a more convenient constructor for conditions.  Each @var{lst} is a list of the following
form:

@lisp
(@var{kind} @vari{property} @vari{value} @varii{property} @varii{value} ...)
@end lisp

In other words, the following:

@lisp
(signal
  (condition '(exn location foo message "hi")
             '(file bar 1)))
@end lisp

@noindent
is equivalent to the @ansrfi{12} code:

@lisp
(signal
  (make-composite-condition
    (make-property-condition 'exn 'location 'foo 'message "hi")
    (make-property-condition 'file 'bar 2)))
@end lisp
@end defun


@defun condition->list @var{condition}
Convert a condition object into a list holding all the conditions that are represented by the
@var{condition} object.  It is formatted as follows:

@example
((@vari{kind} @vari{property} @vari{value} @varii{property} @varii{value} ...)
 (@varii{kind} ...)
 ...)
@end example

There is no guaranteed order within the list.
@end defun


@defun print-error-message @var{exn}
@defunx print-error-message @var{exn} @var{port}
@defunx print-error-message @var{exn} @var{port} @var{header}
Print an appropriate error message to @var{port} (which defaults to the value of
@code{(current-output-port)} for the object @var{exn}. @var{exn} may be a condition, a string or any
other object.  The output is prefixed by the @var{header}, which defaults to @code{"Error:"}.
@end defun

@c page
@node continuation
@chapter Module @library{chicken continuation}


@cindex @library{chicken continuation} module
@cindex Module @library{chicken continuation}

@c page
@node document license
@appendix Document license


Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}@*
Copyright @copyright{} 2007-2019, The CHICKEN Team@*
Copyright @copyright{} 2000-2007, Felix L. Winkelmann@*
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted
provided that the following conditions are met:

@enumerate
@item
Redistributions of source code must retain the above copyright notice, this list of conditions and
the following disclaimer.

@item
Redistributions in binary form must reproduce the above copyright notice, this list of conditions
and the following disclaimer in the documentation and/or other materials provided with the
distribution.

@item
The name of the authors may not be used to endorse or promote products derived from this software
without specific prior written permission.
@end enumerate

THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

@c page
@node srfi
@appendix @srfi{}: Scheme Requests For Implementation

@menu
@c * srfi cond-expand::            @ansrfi{0} feature based conditional
@c                                 expansion construct.
@c * srfi list::                   @ansrfi{1} list library.
@c * srfi and-let-star::           @ansrfi{2} @func{and-let*}: an @func{and}
@c                                 with local bindings, a guarded @func{let*}
@c                                 special form.
@c * srfi string-ports::           @ansrfi{6} basic string ports.
@c * srfi receive::                @ansrfi{8} @func{receive}: Binding to
@c                                 multiple values.
@c * srfi records::                @ansrfi{9} defining record types.
@c * srfi let-values::             @ansrfi{11} syntax for receiving
@c                                 multiple values.
@c * srfi strings::                @ansrfi{13} string library.
@c * srfi case-lambda::            @ansrfi{16} syntax for procedures of
@c                                 variable arity.
@c * srfi time::                   @ansrfi{19} time data types and procedures.
@c * srfi error-reporting::        @ansrfi{23} error reporting mechanism.
@c * srfi shared structures::      @ansrfi{38} representation for data with
@c                                 shared structure.
@c * srfi specialize-procedures::  @ansrfi{26} notation for specializing
@c                                 parameters without currying.
@c * srfi random::                 @ansrfi{27} sources of random bits.
@c * srfi rec::                    @ansrfi{31} a special form @func{rec}
@c                                 for recursive evaluation.
@c * srfi parameters::             @ansrfi{39} parameter objects.
@c * srfi args-fold::              @ansrfi{37} a program argument processor.
@c * srfi streams::                @ansrfi{41} streams.
@c * srfi eager-comp::             @ansrfi{42} eager comprehensions.
@c * srfi vector::                 @ansrfi{43} vector library.
* srfi lazy-evaluation::        @ansrfi{45} lazy evaluation.
@c * srfi general-cond::           @ansrfi{61} a more general @func{cond} clause.
@c * srfi lightweight-testing::    @ansrfi{78} lightweight testing.
@c * srfi environment-variables::  @ansrfi{98} environment variables.
@end menu

@include srfi-45-lazy-evaluation.texi

@c page
@node references
@appendix Bibliography and references


This document is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
@chicken{} can be downloaded from:

@center @url{http://www.call-cc.org/}

@noindent
the package @mmck{} Checks is available from:

@center @url{https://github.com/marcomaggi/mmck-checks/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function

@printindex fn

@node variable index
@appendix An entry for each variable

@printindex vr

@node type index
@appendix An entry for each type

@printindex tp

@contents
@bye

@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c ispell-local-dictionary: "en_GB-ise-w_accents"
@c End:
